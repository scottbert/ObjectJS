(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

/**
 * @author Scott van Looy
 */

/**
 * takes two arrays of strings and combines them, removing duplicates
 * @method combine
 * @param  {Array} arr1 first array to combine
 * @param  {Array} arr2 second array to combine
 * @return {Array}      deduped unsorted array of strings
 */

function combine(arr1, arr2) {
    var tarr = arr1.concat(arr2),
        l = tarr.length,
        o = {},
        ret = [],
        n,
        name;
    for (n = 0; n < l; n++) {
        o[tarr[n]] = true;
    }
    for (name in o) {
        if (o.hasOwnProperty(name)) {
            ret.push(name);
        }
    }
    return ret;
}
/**
 * returns true if we are an array.
 * @method isArray
 * @param  {Array}  o [description]
 * @return {Boolean}   [description]
 */

function isArray(o) {
    return Array.isArray(o);
}

exports.combine = combine;
exports.isArray = isArray;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

function baseController(mixin) {
    /** PRIVATE METHODS **/
    var BaseController = (0, _Shared.augmentObject)({});

    /** API METHODS **/
    /**
     * On enter of your child controller, you call the view associated with that controller
     * using the callView method. It either instantiates the view or if it already exists
     * it calls "enter" on it. Your view's init must also call enter
     * @param  {Object} namespace your namespace
     * @param  {string} view      the name of the view you're calling.
     * @return {Object}           returns the instantiated view.
     */
    BaseController.callView = function callView(namespace, view) {
        if (typeof namespace === 'undefined' || typeof view === 'undefined') {
            BaseController.err('tried to call', view, 'on ', namespace, 'namespace');
            return null;
        }
        if (typeof namespace[view] === 'function') {
            namespace[view] = new namespace[view]();
            namespace[view].controller = this;
            this.view = namespace[view];
        } else {
            namespace[view].enter();
        }
        return namespace[view];
    };
    /**
     * removes tokens in a string and replaces them with values.
     * @param  {string} string  the string to replace tokens in:
     * in the format of "this is my/{token1}-{token2}/string/{token-3}"
     * @param  {Object} tokens an object of tokens to replace:
     * {
     *   token1: 'bert',
     *   token2: 'fred',
     *   token3: 12
     * }
     * @return {string}         tokenised string.
     */
    BaseController.tokeniser = function tokeniser(string, tokens) {
        if (typeof string === 'undefined' || typeof tokens === 'undefined') {
            BaseController.err('tried to tokenise', string, 'with ', tokens);
            return null;
        }
        var token;
        for (token in tokens) {
            if (tokens.hasOwnProperty(token)) {
                string = string.split('{' + token + '}').join(tokens[token]);
            }
        }
        return string;
    };
    /**
     * getData - gets DATA from an external resource using JSON/JSONP. Will POST
     * for JSON requests, can only GET for JSONP. Technically, JSONP is insecure,
     * be very careful when using it, make sure the 3rd party is trustworthy.
     * @param  {Object} options an object containing the information you require.
     *
     * <pre>
     * {
     *   url:{string}          the URL we get the data from. If JSONP, should either
     *                         include ?callback= parameter for services that don't
     *                         allow dynamic callback assignments, or be callback
     *                         parameter free to allow this code to assign one.
     *
     *   data:{string},        name value pairs
     *
     *   success:{function()}, callback function on success. This will be passed
     *                         a data object.
     *
     *   error:{function()},   callback function to do something on error. This will
     *                         be passed an object representing the error.
     *
     *   jsonp:{string}        when set, forces JSONP with the specified string as callback name
     * }
     *
     * </pre>
     */
    BaseController.getData = function getData(options) {
        var xhr;
        if (options.url && typeof options.url === 'string') {
            if (!BaseController.createXHR || !BaseController.createJSONP) {
                mixin.Controller(BaseController);
            }
            // If we're on the same domain, we need to do an XHR request, if not we do a JSONP.
            if (options.url.indexOf('://') === -1 || options.url.match(window.location.protocol) && options.url.indexOf(window.location.host) !== -1 && !options.jsonp) {
                xhr = BaseController.createXHR();
            } else {
                xhr = BaseController.createJSONP(options.jsonp || true);
            }
            xhr.open(options);
        }
    };
    BaseController.createController = BaseController.extend.curry(undefined, BaseController);
    return BaseController;
}
/**
 * @author Scott van Looy
 */

exports.default = baseController;

},{"./Shared":8}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

function baseUI(mixin) {

    var BaseUI = (0, _Shared.augmentObject)({});

    function f(fn) {
        return typeof fn === 'function';
    }

    /** API METHODS **/
    /**
     * Sets the root dom node that the library uses to find other dom nodes when generating UI components. Defaults to body.
     * @param {String|Object} domNode the selector for the domNode
     */
    BaseUI.setRootDomNode = function setRootDomNode(domNode) {
        BaseUI.root = mixin.Selector(domNode);
    };
    /**
     * Sets up a UI, caches its domnode and prepares it for use.
     * @param {String|Object} id - the dom ID, className or jQuery object of the root element for the UI.
     */
    BaseUI.setupUI = function setupUI(id) {
        var self = this;
        function setup() {
            self.domNode = BaseUI.root ? BaseUI.root.find(id) : mixin.Selector(id);
            self.contentNode = self.domNode.find('.content');
            self.titleNode = self.domNode.find('.title');
            self.templateNode = self.domNode.find('.template').remove();
            self.footerNode = self.domNode.find('.footer');
        }
        if (!self.init) {
            mixin.UI(self);
        }
        setup();
    };
    /**
     * Sets the active view on a UI object
     * @param {Object} view a reference to the view we wish to set on the UI object.
     */
    BaseUI.setView = function setView(view) {
        this.view = view;
    };
    /**
     * Gets a reference to the currently set view on a UI object
     * @return {Object} a reference to the currently set view
     */
    BaseUI.getView = function getView() {
        return this.view;
    };
    /**
     *
     * Opens a UI object. Adds a class of "open" to the UI's domNode. Either animate using CSS3
     * or override this to create a Javascript animation.
     * @param  {Object} obj A reference to the UI object
     * @return {Object}     a reference to the UI object (for chaining).
     */
    BaseUI.open = function open(obj) {
        obj = obj || this;
        obj.domNode.addClass('open');
        obj.isOpen = true;
        return obj;
    };
    /**
     * Closes a UI object. Removes the class "open" from the UI's domNode. Either animate using CSS3 or override
     * this to create a Javascript animation.
     * @param  {Function} [cb] Callback to run when the close is complete.
     * @return {Object}     a reference to the UI object (for chaining).
     */
    BaseUI.close = function close(cb) {
        this.domNode.removeClass('open');
        this.isOpen = false;
        if (cb && f(cb)) {
            cb();
        }
        return this;
    };
    /**
     * Returns the contentNode for a UI.
     * @return {Object} a .content node or the domNode of the UI in question.
     */
    BaseUI.getContentNode = function () {
        return this.contentNode;
    };
    /**
     * Add methods to the UI object you're creating. Automatically create super methods when the object you're
     * passing in contains thesame methods as its parent.
     * @param {Object} options Object containing the methods you wish to add to the host object.
     */
    BaseUI.addMethods = function (options) {
        var method, args;
        for (method in options) {
            if (options.hasOwnProperty(method) && typeof method === 'function') {
                if (!this[method]) {
                    this[method] = options[method];
                } else {
                    options['super' + method] = this[method];
                    this[method] = function () {
                        if (arguments.length === 1) {
                            args = arguments[0];
                        } else {
                            args = arguments;
                        }
                        options[method](args);
                        options['super' + method](args);
                    };
                }
            }
        }
    };
    /**
     * Takes an object and extends it with the BaseUI
     * @param {Object} object to extend;
     * @return {Object} extended object
     */
    BaseUI.createUI = BaseUI.extend.curry(undefined, BaseUI);
    return BaseUI;
} /**
   * @author Scott van Looy
   */

exports.default = baseUI;

},{"./Shared":8}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

var _ArrayUtils = require('./ArrayUtils');

/**
 * @author Scott van Looy
 */

/** PRIVATE METHODS **/
function baseView(mixin) {
    var BaseView = (0, _Shared.augmentObject)({}),
        defaults = [],
        loadComponents = function loadComponents(namespace, uisArray, view, addToDefaults) {
        var arr = (0, _ArrayUtils.combine)(defaults, uisArray),
            l = arr.length,
            ret = {};
        view = view || {};
        while (l--) {
            if (arr[l] && namespace[arr[l]]) {
                if (typeof namespace[arr[l]] === 'function') {
                    namespace[arr[l]] = new namespace[arr[l]](view);
                } else {
                    namespace[arr[l]].setView(view);
                }
                if (addToDefaults) {
                    defaults.push(arr[l]);
                }
                ret[arr[l]] = namespace[arr[l]];
            }
        }
        return ret;
    };
    /** API METHODS **/
    /**
     * Sets default UIs. These UIs appear on every page. Should only be
     * called once in your project as it replaces everything each time.
     * generally you would call this from your app view.
     * @param {Object} ns - the namespace your UIs can be found under.
     * @param {String} arr - An array of UI names.
     */
    BaseView.setDefaultComponents = function setDefaultComponents(namespace, arr) {
        defaults = [];
        return loadComponents(namespace, arr, null, true);
    };
    /**
     * returns the array of default components.
     * @return {Array} [description]
     */
    BaseView.getDefaultComponents = function getDefaultComponents() {
        return defaults;
    };
    /**
     * All views require a set of components that exist within that view. Every
     * view should have an enter method that calls requires and adds the following.
     * @param  {Object} namespace your namespace
     * @param  {String[]} arr       an array of strings containing UI component names
     * @param  {Object}                a reference to the view object
     * @return {String[]}           array of objects
     */
    BaseView.requires = function requires(namespace, arr, view) {
        var uiMap = (0, _ArrayUtils.combine)(arr, defaults);
        view.uis = loadComponents(namespace, uiMap, view);
        return view.uis;
    };
    BaseView.routes = function () {
        //write code
    };
    BaseView.captureRoutes = function routes() {
        //write code
    };
    BaseView.captureForms = function captureForms() {
        //write code
    };
    /**
     * Takes an object and extends it with the BaseView
     * @param {Object} object to extend;
     * @return {Object} extended object
     */
    BaseView.createView = BaseView.extend.curry(undefined, BaseView);
    /**
     * This is where you can find an object representing your UIs once you've called requires
     * @type {Object}
     */
    BaseView.uis = null;
    /**
     * This is a reference to the controller that instantiated the view
     * @type {Object}
     */
    BaseView.controller = null;

    return BaseView;
}
exports.default = baseView;

},{"./ArrayUtils":1,"./Shared":8}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

var _BaseUI = require('./BaseUI');

var _BaseUI2 = _interopRequireDefault(_BaseUI);

var _BaseController = require('./BaseController');

var _BaseController2 = _interopRequireDefault(_BaseController);

var _BaseView = require('./BaseView');

var _BaseView2 = _interopRequireDefault(_BaseView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author Scott van Looy
 * @name { ObjectJS:[name]}
 */
function ojs(options) {
    var currentView = void 0,
        views = void 0,
        Mixin = options.Mixin,
        Selector = Mixin.Selector;

    function ObjectJS(node) {
        return Selector(node);
    }

    /**
     * The base URL for library scripts - determined by the location of
     * object.min?.js
     * @return {string}
     */

    var BASE_URL = function () {
        if (!document) {
            return null;
        }
        var s = document.getElementsByTagName('script');
        var m = s[s.length - 1];
        return m.src.replace(/[^\/]+?$/, '');
    }();

    /**
     * Load a script asynchronously.
     * @param  {string}   src  href of the script to load.
     * @param  {Function} cb   callback to fire upon loading.
     * @param  {Number}   load Scripts remaining to load.
     * @param  {Number}   len  Total scripts to load
     * @param  {Number}   num  Script index
     * @param  {Function}   err  Something to do on error.
     */
    function loadScript(src, cb, load, len, num, err) {

        function loaded() {
            var state = s.state;
            if (!state || /loaded|complete/.test(state)) {
                load--;
                if (!load && len === num) {
                    if (cb && typeof cb === 'function' && !cb.called) {
                        cb.call(this);
                        cb.called = true;
                    }
                }
            }
        }

        function error() {
            if (err && typeof err === 'function' && !err.called) {
                err.call(this);
                err.called = true;
            }
        }
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = src;
        s.async = false;
        s.onload = s.onreadystatechange = loaded;
        s.onerror = error;
        ObjectJS('head').append(s);
    }

    /**
     * Requests a namespace. If the namespace does not exist, it will
     * be created
     * @param {String} req - request in the format of 'my.name.space'
     * @param {Object} test - test for a mamespace.
     * @return {Object|false} The namespace or false if test is true and the namespace doesn't exist
     */
    function reqNameSpace(req, test) {
        var t, x, tns, l;
        if (!req || typeof req !== 'string') {
            (0, _Shared.err)('getNameSpace error - requires a string in the format "my.name.space"');
            return null;
        }
        if (!req.match('\\.')) {
            t = [req];
        } else {
            t = req.split('.');
        }
        tns = window;
        l = t.length;
        for (x = 0; x < l; x++) {
            if (tns[t[x]]) {
                tns = tns[t[x]];
            } else {
                if (test) {
                    return false;
                }
                tns = tns[t[x]] = {};
            }
        }
        return tns;
    }
    /**
     * requires method. Using the location of object.min?.js as the base, can
     * load other modules. Checks to see if they exist and if they don't, we grab
     * the module.
     * @param {Array} requires - array of strings representing a component's path.
     * 'myapp/main/Hello.js' would be written as 'myapp.main.Hello' and Hello.js
     * would contains an object at the same namespace
     * (myapp.main.Hello = (function(){}()))
     * @param {Function} [callback]. Optional callback to run when loading is complete.
     */
    function requires(requires, callback, oj) {
        var l = requires.length,
            src,
            load = 0,
            n,
            docallback = false,
            namespaceTest;
        oj = oj || 'ns';
        namespaceTest = function namespaceTest(namespace, test) {
            var ret = namespace,
                strArr = test.split('.'),
                l = strArr.length,
                p;
            // Find starting point. Either our own namespace or the window. If neither, return false.
            if (!ret[strArr[0]] && !window[strArr[0]]) {
                return undefined;
            }
            // If starting point is the window, set window to the return value.
            if (!ret[strArr[0]] && window[strArr[0]]) {
                ret = window;
            }
            for (p = 0; p < l; p++) {
                if (ret !== undefined) {
                    ret = ret[strArr[p]];
                }
            }
            return ret;
        };
        if (typeof requires === 'string') {
            requires = [requires];
            l = requires.length;
        }
        for (n = 0; n < l; n++) {
            docallback = false;
            src = null;
            if (namespaceTest(oj, requires[n]) === undefined) {
                src = BASE_URL + requires[n].replace(/\./gi, '/') + '.js';
                if (oj.finished) {
                    loadScript(src, callback, load, requires.length, n);
                } else {
                    docallback = true;
                    document.write('<script type="text/javascript" src="' + src + '"><\/script>');
                }
            } else {
                // We already have this item. Run callback.
                docallback = true;
            }
        }
        if (docallback) {
            if (callback) {
                callback();
            }
        }
    }

    /**
     * Initialise an object
     * @param  {String}   obj the name of the object to initialise
     * @param  {Object}   ns  the namespace it lives in
     * @param  {String} [fn]  A function to run on the newly initialised object.
     * @return {Object}       The new object
     */
    function initObj(obj, ns, fn) {
        if (!ns || !ns[obj]) {
            (0, _Shared.err)('Attempted to init object', obj, 'in namespace', ns, 'failed.');
            return null;
        }
        if (typeof ns[obj] === 'function') {
            ns[obj] = new ns[obj]();
        }
        if (ns[obj][fn]) {
            ns[obj][fn]();
        }
        return ns[obj];
    }
    /**
     * Returns a reference to the current active view.
     * @return {Object} a reference to the current active view.
     */
    function getView() {
        return currentView;
    }
    /**
     * Calls a view. Used at the bottom of an HTML page to call the associated JS view with that page.
     * @param  {String} view The view name
     */
    function view(view) {
        initObj(view, views, 'enter');
        currentView = views[view];
    }

    /**
     * initialise the object
     * @private
     */
    function init() {
        Function.prototype.curry = Function.prototype.partial || function curry() {
            var fn = this,
                args = Array.prototype.slice.call(arguments);
            return function () {
                var myArgs = Array.prototype.slice.call(arguments),
                    combined = [];
                var i,
                    ii,
                    l = args.length,
                    ll = myArgs.length;
                for (i = 0; i < l; i++) {
                    if (args[i] === undefined) {
                        for (ii = 0; ii < ll; ii++) {
                            combined.push(myArgs[ii]);
                        }
                    } else {
                        combined.push(args[i]);
                    }
                }
                return fn.apply(this, combined);
            };
        };
    }

    init();

    var baseUI = (0, _BaseUI2.default)(Mixin);
    var baseController = (0, _BaseController2.default)(Mixin);
    var baseView = (0, _BaseView2.default)(Mixin);

    ObjectJS.NOOP = function () {};
    ObjectJS.reqNameSpace = reqNameSpace;
    ObjectJS.requires = requires;
    ObjectJS.BASE_URL = BASE_URL;
    ObjectJS.augmentObject = _Shared.augmentObject;
    ObjectJS.initObj = initObj;
    ObjectJS.getView = getView;
    ObjectJS.view = view;
    ObjectJS.loadScript = loadScript;
    ObjectJS.err = _Shared.err;
    ObjectJS.log = _Shared.log;
    ObjectJS.warn = _Shared.warn;
    ObjectJS.createUI = baseUI.createUI;
    ObjectJS.setRootDomNode = baseUI.setRootDomNode;
    ObjectJS.createView = baseView.createView;
    ObjectJS.createController = baseController.createController;
    return ObjectJS;
}

exports.default = ojs;

},{"./BaseController":2,"./BaseUI":3,"./BaseView":4,"./Shared":8}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * @author scottvanlooy
 */
var ObjectJS = require('./ObjectJS');

var OBJMIXINS,
    UIMIXINS,
    that,
    dataObj = {},
    eventBind,
    eventPrefix;
function getAttr(str, attr) {
    return (str.split(new RegExp('\\b' + attr + '='))[1] || '').split('&')[0];
}

function hijack(callback) {
    return function (e) {
        if (!e || !e.stopPropagation) {
            e = {
                stopPropagation: window.event.cancelBubble,
                preventDefault: function preventDefault() {
                    window.event.returnValue = false;
                }
            };
        }
        callback(e);
    };
}

function NativeUI(object) {
    var i;
    for (i in OBJMIXINS) {
        if (OBJMIXINS.hasOwnProperty(i)) {
            object[i] = OBJMIXINS[i];
        }
    }
}

function NativeSelector(id, node) {
    if (!document.querySelectorAll) {
        throw 'Old browser, please use jQuery mixin';
    }
    var Node;
    // If we're just an ID, get us. getElementById is faster than querySelectorAll -
    // this currently works about 10 times faster than jQuery for single IDs and
    // nearly twice as fast for more complex queries.
    if (id.charAt(0) === '#' && id.indexOf(' ') === -1) {
        Node = [document.getElementById(id.substring(1))];
    } else {
        Node = ((node || [])[0] || document).querySelectorAll(id);
    }
    if (!Node) {
        Node = [];
    }
    augment(Node);
    return Node;
}

function checkDelay(NodeList, closure) {
    var l, ret, node;
    if (!NodeList.length) {
        NodeList = [NodeList];
    }
    l = NodeList.length;
    function r(n) {
        setTimeout(function () {
            closure();
        }, n.tdelay);
    }
    while (l--) {
        node = NodeList[l];
        if (node.tdelay) {
            if (!node.ttimers) {
                node.ttimers = [];
            }
            node.ttimers.push(r(node));
            ret = true;
        }
    }
    return ret ? augment(NodeList) : closure();
}

function NativeController(Controller) {
    Controller.createXHR = function createXHR() {
        var xhr;
        if (window.XMLHttpRequest) {
            xhr = new window.XMLHttpRequest();
        } else if (window.ActiveXObject) {
            xhr = new window.ActiveXObject('MSXML2.XMLHTTP.3.0');
        } else {
            return null;
        }
        return xhr;
    };
    Controller.createJSONP = function createJSONP(cbname) {
        var fn = typeof cbname === 'string' ? cbname : 'f' + new Date().getTime().toString(16),
            JSONP = {};
        JSONP.open = function (options) {
            var c,
                t,
                url = options.url,
                callback = options.success,
                error = options.error;
            function cb() {
                if (callback) {
                    if (c > 10000) {
                        if (error) {
                            error('Didn\'t get any data after 10s, check ?callback');
                        }
                    }
                    if (typeof dataObj[fn] !== 'undefined') {
                        callback(dataObj[fn]);
                    } else {
                        setTimeout(cb, 100);
                    }
                }
            }
            t = getAttr(url, 'callback');
            if (t) {
                fn = t;
            } else {
                c = '?callback';
                if (url.indexOf('?') !== -1) {
                    c = '&callback';
                }
                url += c + '=' + fn;
            }
            window[fn] = function (data) {
                dataObj[fn] = data;
            };
            try {
                ObjectJS.loadScript(url, cb, 1, 0, 0, error);
            } catch (ex) {
                error(ex);
            }
        };
        JSONP.error = function () {
            //something
        };
        return JSONP;
    };
}
function augment(Nodes) {
    var i;
    if (!Nodes.augmented) {
        for (i in UIMIXINS) {
            if (UIMIXINS.hasOwnProperty(i)) {
                Nodes[i] = UIMIXINS[i];
            }
        }
        Nodes.augmented = true;
    }
    return Nodes;
}
OBJMIXINS = {
    superOpen: function superOpen(callback) {
        that = that || this;
        that.domNode.style.display = 'block';
        return callback ? callback() : null;
    },
    superClose: function superClose(callback) {
        that = that || this;
        that.domNode.style.display = 'none';
        return callback ? callback() : null;
    },
    on: function on() {
        that = that || this;
        that.domNode.style.display = 'block';
    },
    off: function off() {
        that = that || this;
        that.domNode.style.display = 'none';
    }
};
UIMIXINS = {
    init: true,
    find: function find(str) {
        var nodes = this,
            l,
            nl,
            nll,
            ret = [];
        if (nodes.length) {
            nodes = [nodes];
        }
        l = nodes.length;
        while (l--) {
            nl = NativeSelector(str, nodes[l]);
            nll = nl.length;
            while (nll--) {
                ret.push(nl[nll]);
            }
        }
        return augment(ret);
    },
    remove: function remove() {
        var NodeList = this,
            ret = [],
            l = NodeList.length,
            n;
        return checkDelay(NodeList, function () {
            if (!NodeList.item && !Array.isArray(NodeList)) {
                NodeList = [NodeList];
            }
            for (n = 0; n < l; n++) {
                NodeList[n].parentNode.removeChild(NodeList[n]);
                ret.push(augment(NodeList));
            }
            return augment(ret);
        });
    },
    bind: function bind(str, func) {
        var NodeList = this,
            ret = [],
            l,
            n;
        return checkDelay(NodeList, function () {
            if (!NodeList.item) {
                NodeList = [NodeList];
            }
            l = NodeList.length;
            if (!eventBind) {
                if (NodeList[0].addEventListener) {
                    eventBind = 'addEventListener';
                    eventPrefix = '';
                } else {
                    eventBind = 'attachEvent';
                    eventPrefix = 'on';
                }
            }
            for (n = 0; n < l; n++) {
                if (NodeList[n][eventBind]) {
                    NodeList[n][eventBind](eventPrefix + str, hijack(func), true);
                }
                ret.push(augment(NodeList[n]));
            }
            return ret;
        });
    },
    addClass: function addClass(classNames) {
        var Node = this;
        function p(o, c) {
            var e = o || '',
                pa,
                l,
                ia = false,
                pia = e.indexOf(' ') !== -1,
                cia = c.indexOf(' ') !== -1,
                cs;
            if (pia || cia) {
                if (pia && cia) {
                    return ObjectJS.core.utils.ArrayUtils.combine(e.split(' '), c.split(' ')).join(' ');
                }
                pa = pia ? e.split(' ') : c.split(' ');
                cs = pia ? c : e;
                l = pa.length;
                while (l--) {
                    if (pa[l] === cs) {
                        ia = true;
                    }
                }
                if (!ia && cs !== '') {
                    pa.push(cs.trim ? cs.trim() : cs);
                }
                return pa.join(' ');
            }
            return e === '' ? c : e + ' ' + c;
        }
        return checkDelay(Node, function () {
            if (Node.length) {
                var l = Node.length;
                while (l-- && Node[l].setAttribute) {
                    Node[l].setAttribute('class', p(Node[l].getAttribute('class'), classNames));
                }
            } else if (Node.setAttribute) {
                Node.setAttribute('class', p(Node.getAttribute('class'), classNames));
            }
            return augment(Node);
        });
        // more than one class
    },
    removeClass: function removeClass(classNames) {
        var Node = this,
            node,
            ret,
            l;
        if (!Node.item) {
            Node = [Node];
        }
        l = Node.length;
        function d(o, s) {
            o.setAttribute('class', s.trim ? o.getAttribute('class').replace(s, '').trim() : o.getAttribute('class').replace(s, ''));
        }
        function m(o, cn) {
            var ca = cn.split(' '),
                cl = ca.length;
            if (cl) {
                while (cl--) {
                    d(o, ca[cl]);
                }
            } else {
                d(o, cn);
            }
        }
        function r(n) {
            return function () {
                m(n, classNames);
            };
        }
        while (l--) {
            node = Node[l];
            ret = checkDelay(node, r(node));
        }
        return Node;
    },
    setClass: function setClass(classNames) {
        var Node = this,
            node,
            ret,
            l;
        if (!Node.item) {
            Node = [Node];
        }
        l = Node.length;
        function r(n) {
            return function () {
                if (n.setAttribute) {
                    n.setAttribute('class', classNames.trim());
                }
            };
        }
        while (l--) {
            node = Node[l];
            ret = checkDelay(node, r(node));
        }
        return Node;
    },
    hasClass: function hasClass(className) {
        var i,
            n = this,
            l;
        if (!l) {
            n = [this];
        }
        l = n.length;
        for (i = 0; i < l; i++) {
            if (n[i].className && n[i].className.split && n[i].className.split(' ').indexOf(className) !== -1) {
                return true;
            }
        }
        return false;
    },
    html: function html(content) {
        var Node = this;
        return checkDelay(Node, function () {
            var ret = Node.length ? Node[0] : Node;
            if (content) {
                ret.innerHTML = content;
            }
            return ret.innerHTML && ret.innerHTML.trim ? ret.innerHTML.trim() : ret.innerHTML;
        });
    },
    randomDelay: function randomDelay(number) {
        var Node = this,
            intn,
            l;
        if (!Node.item) {
            intn = [Node];
        } else {
            intn = Node;
        }
        l = intn.length;
        while (l--) {
            augment(intn[l]).delay(Math.random() * number);
        }
        return Node;
    },
    delay: function delay(number) {
        var Node = this,
            intn,
            l;
        if (!Node.item) {
            intn = [Node];
        } else {
            intn = Node;
        }
        l = intn.length;
        while (l--) {
            if (!intn[l].tdelay) {
                intn[l].tdelay = parseInt(number, 10);
            } else {
                intn[l].tdelay += parseInt(number, 10);
            }
        }
        return Node;
    },
    hide: function hide() {
        var Node = this,
            l;
        if (!Node.item) {
            Node = [Node];
        }
        l = Node.length;
        if (!Node[0].style) {
            return Node;
        } else {
            while (l--) {
                Node[l].style.display = 'none';
            }
            return Node;
        }
    },
    show: function show() {
        var Node = this,
            l;
        if (!Node.item) {
            Node = [Node];
        }
        l = Node.length;
        while (l--) {
            Node[l].style.display = '';
        }
        return Node;
    }
};

exports.default = {
    UI: NativeUI,
    Selector: NativeSelector,
    Controller: NativeController
};

},{"./ObjectJS":7}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Native = require('./Native');

var _Native2 = _interopRequireDefault(_Native);

var _Core = require('./Core');

var _Core2 = _interopRequireDefault(_Core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ObjectJS() {
    var core = new _Core2.default({
        Mixin: _Native2.default
    });
    if (window) {
        window.ObjectJS = core;
    }
    return core;
}
exports.default = ObjectJS();

},{"./Core":5,"./Native":6}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function err() {
    if (window && window.console && window.location.href === 'debug') {
        window.console.error(arguments);
    }
    return true;
}
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function log() {
    if (window && window.console && window.location.href.indexOf('debug') !== -1) {
        window.console.log(arguments);
    }
    return true;
}
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function warn() {
    if (window && window.console && window.location.href.indexOf('debug') !== -1) {
        window.console.warn(arguments);
    }
    return true;
}

/**
 * Augment the object, adding a few shared methods to it.
 * @param  {Object} object the object to be augmented
 * @return {Object} the augmented object.
 */
function augmentObject(object) {
    if (typeof object === 'undefined') {
        err('tried to augment', object);
        return null;
    }
    if (!object.augmented) {
        /**
         * extend an object with another object.
         *
         * @param  {Function} item       child function
         * @param  {Function|Object} Inheritant parent function/object
         *
         * @return {Object}            Returns the object with its augmentation
         */
        object.extend = object.extend || function extend(Child, Parent) {
            if (typeof Child === 'undefined' || typeof Parent === 'undefined') {
                err('Tried to extend', Child, 'with', Parent);
                return null;
            }
            if (typeof Parent === 'function') {
                Child.prototype = new Parent();
                Child.constructor = Child;
            } else {
                Child.prototype = Parent;
                Child.constructor = Child;
            }
        };
        object.augmented = true;
    }
    return object;
}
exports.augmentObject = augmentObject;
exports.err = err;
exports.log = log;
exports.warn = warn;

},{}]},{},[7]);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJvYmplY3Rqcy5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBAYXV0aG9yIFNjb3R0IHZhbiBMb295XG4gKi9cblxuLyoqXG4gKiB0YWtlcyB0d28gYXJyYXlzIG9mIHN0cmluZ3MgYW5kIGNvbWJpbmVzIHRoZW0sIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBtZXRob2QgY29tYmluZVxuICogQHBhcmFtICB7QXJyYXl9IGFycjEgZmlyc3QgYXJyYXkgdG8gY29tYmluZVxuICogQHBhcmFtICB7QXJyYXl9IGFycjIgc2Vjb25kIGFycmF5IHRvIGNvbWJpbmVcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgIGRlZHVwZWQgdW5zb3J0ZWQgYXJyYXkgb2Ygc3RyaW5nc1xuICovXG5cbmZ1bmN0aW9uIGNvbWJpbmUoYXJyMSwgYXJyMikge1xuICAgIHZhciB0YXJyID0gYXJyMS5jb25jYXQoYXJyMiksXG4gICAgICAgIGwgPSB0YXJyLmxlbmd0aCxcbiAgICAgICAgbyA9IHt9LFxuICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgbixcbiAgICAgICAgbmFtZTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgbDsgbisrKSB7XG4gICAgICAgIG9bdGFycltuXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gbykge1xuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgcmV0LnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogcmV0dXJucyB0cnVlIGlmIHdlIGFyZSBhbiBhcnJheS5cbiAqIEBtZXRob2QgaXNBcnJheVxuICogQHBhcmFtICB7QXJyYXl9ICBvIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXkobykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG8pO1xufVxuXG5leHBvcnRzLmNvbWJpbmUgPSBjb21iaW5lO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxufSx7fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TaGFyZWQgPSByZXF1aXJlKCcuL1NoYXJlZCcpO1xuXG5mdW5jdGlvbiBiYXNlQ29udHJvbGxlcihtaXhpbikge1xuICAgIC8qKiBQUklWQVRFIE1FVEhPRFMgKiovXG4gICAgdmFyIEJhc2VDb250cm9sbGVyID0gKDAsIF9TaGFyZWQuYXVnbWVudE9iamVjdCkoe30pO1xuXG4gICAgLyoqIEFQSSBNRVRIT0RTICoqL1xuICAgIC8qKlxuICAgICAqIE9uIGVudGVyIG9mIHlvdXIgY2hpbGQgY29udHJvbGxlciwgeW91IGNhbGwgdGhlIHZpZXcgYXNzb2NpYXRlZCB3aXRoIHRoYXQgY29udHJvbGxlclxuICAgICAqIHVzaW5nIHRoZSBjYWxsVmlldyBtZXRob2QuIEl0IGVpdGhlciBpbnN0YW50aWF0ZXMgdGhlIHZpZXcgb3IgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgKiBpdCBjYWxscyBcImVudGVyXCIgb24gaXQuIFlvdXIgdmlldydzIGluaXQgbXVzdCBhbHNvIGNhbGwgZW50ZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5hbWVzcGFjZSB5b3VyIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdmlldyAgICAgIHRoZSBuYW1lIG9mIHRoZSB2aWV3IHlvdSdyZSBjYWxsaW5nLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIHJldHVybnMgdGhlIGluc3RhbnRpYXRlZCB2aWV3LlxuICAgICAqL1xuICAgIEJhc2VDb250cm9sbGVyLmNhbGxWaWV3ID0gZnVuY3Rpb24gY2FsbFZpZXcobmFtZXNwYWNlLCB2aWV3KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEJhc2VDb250cm9sbGVyLmVycigndHJpZWQgdG8gY2FsbCcsIHZpZXcsICdvbiAnLCBuYW1lc3BhY2UsICduYW1lc3BhY2UnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlW3ZpZXddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2Vbdmlld10gPSBuZXcgbmFtZXNwYWNlW3ZpZXddKCk7XG4gICAgICAgICAgICBuYW1lc3BhY2Vbdmlld10uY29udHJvbGxlciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBuYW1lc3BhY2Vbdmlld107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lc3BhY2Vbdmlld10uZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXNwYWNlW3ZpZXddO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmVtb3ZlcyB0b2tlbnMgaW4gYSBzdHJpbmcgYW5kIHJlcGxhY2VzIHRoZW0gd2l0aCB2YWx1ZXMuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgIHRoZSBzdHJpbmcgdG8gcmVwbGFjZSB0b2tlbnMgaW46XG4gICAgICogaW4gdGhlIGZvcm1hdCBvZiBcInRoaXMgaXMgbXkve3Rva2VuMX0te3Rva2VuMn0vc3RyaW5nL3t0b2tlbi0zfVwiXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSB0b2tlbnMgYW4gb2JqZWN0IG9mIHRva2VucyB0byByZXBsYWNlOlxuICAgICAqIHtcbiAgICAgKiAgIHRva2VuMTogJ2JlcnQnLFxuICAgICAqICAgdG9rZW4yOiAnZnJlZCcsXG4gICAgICogICB0b2tlbjM6IDEyXG4gICAgICogfVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICB0b2tlbmlzZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIEJhc2VDb250cm9sbGVyLnRva2VuaXNlciA9IGZ1bmN0aW9uIHRva2VuaXNlcihzdHJpbmcsIHRva2Vucykge1xuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRva2VucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEJhc2VDb250cm9sbGVyLmVycigndHJpZWQgdG8gdG9rZW5pc2UnLCBzdHJpbmcsICd3aXRoICcsIHRva2Vucyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIGZvciAodG9rZW4gaW4gdG9rZW5zKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zcGxpdCgneycgKyB0b2tlbiArICd9Jykuam9pbih0b2tlbnNbdG9rZW5dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0RGF0YSAtIGdldHMgREFUQSBmcm9tIGFuIGV4dGVybmFsIHJlc291cmNlIHVzaW5nIEpTT04vSlNPTlAuIFdpbGwgUE9TVFxuICAgICAqIGZvciBKU09OIHJlcXVlc3RzLCBjYW4gb25seSBHRVQgZm9yIEpTT05QLiBUZWNobmljYWxseSwgSlNPTlAgaXMgaW5zZWN1cmUsXG4gICAgICogYmUgdmVyeSBjYXJlZnVsIHdoZW4gdXNpbmcgaXQsIG1ha2Ugc3VyZSB0aGUgM3JkIHBhcnR5IGlzIHRydXN0d29ydGh5LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24geW91IHJlcXVpcmUuXG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIHtcbiAgICAgKiAgIHVybDp7c3RyaW5nfSAgICAgICAgICB0aGUgVVJMIHdlIGdldCB0aGUgZGF0YSBmcm9tLiBJZiBKU09OUCwgc2hvdWxkIGVpdGhlclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgP2NhbGxiYWNrPSBwYXJhbWV0ZXIgZm9yIHNlcnZpY2VzIHRoYXQgZG9uJ3RcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvdyBkeW5hbWljIGNhbGxiYWNrIGFzc2lnbm1lbnRzLCBvciBiZSBjYWxsYmFja1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlciBmcmVlIHRvIGFsbG93IHRoaXMgY29kZSB0byBhc3NpZ24gb25lLlxuICAgICAqXG4gICAgICogICBkYXRhOntzdHJpbmd9LCAgICAgICAgbmFtZSB2YWx1ZSBwYWlyc1xuICAgICAqXG4gICAgICogICBzdWNjZXNzOntmdW5jdGlvbigpfSwgY2FsbGJhY2sgZnVuY3Rpb24gb24gc3VjY2Vzcy4gVGhpcyB3aWxsIGJlIHBhc3NlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGEgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAgIGVycm9yOntmdW5jdGlvbigpfSwgICBjYWxsYmFjayBmdW5jdGlvbiB0byBkbyBzb21ldGhpbmcgb24gZXJyb3IuIFRoaXMgd2lsbFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHBhc3NlZCBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBlcnJvci5cbiAgICAgKlxuICAgICAqICAganNvbnA6e3N0cmluZ30gICAgICAgIHdoZW4gc2V0LCBmb3JjZXMgSlNPTlAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcyBjYWxsYmFjayBuYW1lXG4gICAgICogfVxuICAgICAqXG4gICAgICogPC9wcmU+XG4gICAgICovXG4gICAgQmFzZUNvbnRyb2xsZXIuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEob3B0aW9ucykge1xuICAgICAgICB2YXIgeGhyO1xuICAgICAgICBpZiAob3B0aW9ucy51cmwgJiYgdHlwZW9mIG9wdGlvbnMudXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFCYXNlQ29udHJvbGxlci5jcmVhdGVYSFIgfHwgIUJhc2VDb250cm9sbGVyLmNyZWF0ZUpTT05QKSB7XG4gICAgICAgICAgICAgICAgbWl4aW4uQ29udHJvbGxlcihCYXNlQ29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvbiB0aGUgc2FtZSBkb21haW4sIHdlIG5lZWQgdG8gZG8gYW4gWEhSIHJlcXVlc3QsIGlmIG5vdCB3ZSBkbyBhIEpTT05QLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsLmluZGV4T2YoJzovLycpID09PSAtMSB8fCBvcHRpb25zLnVybC5tYXRjaCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpICYmIG9wdGlvbnMudXJsLmluZGV4T2Yod2luZG93LmxvY2F0aW9uLmhvc3QpICE9PSAtMSAmJiAhb3B0aW9ucy5qc29ucCkge1xuICAgICAgICAgICAgICAgIHhociA9IEJhc2VDb250cm9sbGVyLmNyZWF0ZVhIUigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4aHIgPSBCYXNlQ29udHJvbGxlci5jcmVhdGVKU09OUChvcHRpb25zLmpzb25wIHx8IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLm9wZW4ob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJhc2VDb250cm9sbGVyLmNyZWF0ZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlci5leHRlbmQuY3VycnkodW5kZWZpbmVkLCBCYXNlQ29udHJvbGxlcik7XG4gICAgcmV0dXJuIEJhc2VDb250cm9sbGVyO1xufVxuLyoqXG4gKiBAYXV0aG9yIFNjb3R0IHZhbiBMb295XG4gKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gYmFzZUNvbnRyb2xsZXI7XG5cbn0se1wiLi9TaGFyZWRcIjo4fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TaGFyZWQgPSByZXF1aXJlKCcuL1NoYXJlZCcpO1xuXG5mdW5jdGlvbiBiYXNlVUkobWl4aW4pIHtcblxuICAgIHZhciBCYXNlVUkgPSAoMCwgX1NoYXJlZC5hdWdtZW50T2JqZWN0KSh7fSk7XG5cbiAgICBmdW5jdGlvbiBmKGZuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqIEFQSSBNRVRIT0RTICoqL1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJvb3QgZG9tIG5vZGUgdGhhdCB0aGUgbGlicmFyeSB1c2VzIHRvIGZpbmQgb3RoZXIgZG9tIG5vZGVzIHdoZW4gZ2VuZXJhdGluZyBVSSBjb21wb25lbnRzLiBEZWZhdWx0cyB0byBib2R5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZG9tTm9kZSB0aGUgc2VsZWN0b3IgZm9yIHRoZSBkb21Ob2RlXG4gICAgICovXG4gICAgQmFzZVVJLnNldFJvb3REb21Ob2RlID0gZnVuY3Rpb24gc2V0Um9vdERvbU5vZGUoZG9tTm9kZSkge1xuICAgICAgICBCYXNlVUkucm9vdCA9IG1peGluLlNlbGVjdG9yKGRvbU5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBhIFVJLCBjYWNoZXMgaXRzIGRvbW5vZGUgYW5kIHByZXBhcmVzIGl0IGZvciB1c2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBpZCAtIHRoZSBkb20gSUQsIGNsYXNzTmFtZSBvciBqUXVlcnkgb2JqZWN0IG9mIHRoZSByb290IGVsZW1lbnQgZm9yIHRoZSBVSS5cbiAgICAgKi9cbiAgICBCYXNlVUkuc2V0dXBVSSA9IGZ1bmN0aW9uIHNldHVwVUkoaWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAgICAgICAgIHNlbGYuZG9tTm9kZSA9IEJhc2VVSS5yb290ID8gQmFzZVVJLnJvb3QuZmluZChpZCkgOiBtaXhpbi5TZWxlY3RvcihpZCk7XG4gICAgICAgICAgICBzZWxmLmNvbnRlbnROb2RlID0gc2VsZi5kb21Ob2RlLmZpbmQoJy5jb250ZW50Jyk7XG4gICAgICAgICAgICBzZWxmLnRpdGxlTm9kZSA9IHNlbGYuZG9tTm9kZS5maW5kKCcudGl0bGUnKTtcbiAgICAgICAgICAgIHNlbGYudGVtcGxhdGVOb2RlID0gc2VsZi5kb21Ob2RlLmZpbmQoJy50ZW1wbGF0ZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgc2VsZi5mb290ZXJOb2RlID0gc2VsZi5kb21Ob2RlLmZpbmQoJy5mb290ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGYuaW5pdCkge1xuICAgICAgICAgICAgbWl4aW4uVUkoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXAoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSB2aWV3IG9uIGEgVUkgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZpZXcgYSByZWZlcmVuY2UgdG8gdGhlIHZpZXcgd2Ugd2lzaCB0byBzZXQgb24gdGhlIFVJIG9iamVjdC5cbiAgICAgKi9cbiAgICBCYXNlVUkuc2V0VmlldyA9IGZ1bmN0aW9uIHNldFZpZXcodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHNldCB2aWV3IG9uIGEgVUkgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHNldCB2aWV3XG4gICAgICovXG4gICAgQmFzZVVJLmdldFZpZXcgPSBmdW5jdGlvbiBnZXRWaWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPcGVucyBhIFVJIG9iamVjdC4gQWRkcyBhIGNsYXNzIG9mIFwib3BlblwiIHRvIHRoZSBVSSdzIGRvbU5vZGUuIEVpdGhlciBhbmltYXRlIHVzaW5nIENTUzNcbiAgICAgKiBvciBvdmVycmlkZSB0aGlzIHRvIGNyZWF0ZSBhIEphdmFzY3JpcHQgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb2JqIEEgcmVmZXJlbmNlIHRvIHRoZSBVSSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBhIHJlZmVyZW5jZSB0byB0aGUgVUkgb2JqZWN0IChmb3IgY2hhaW5pbmcpLlxuICAgICAqL1xuICAgIEJhc2VVSS5vcGVuID0gZnVuY3Rpb24gb3BlbihvYmopIHtcbiAgICAgICAgb2JqID0gb2JqIHx8IHRoaXM7XG4gICAgICAgIG9iai5kb21Ob2RlLmFkZENsYXNzKCdvcGVuJyk7XG4gICAgICAgIG9iai5pc09wZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGEgVUkgb2JqZWN0LiBSZW1vdmVzIHRoZSBjbGFzcyBcIm9wZW5cIiBmcm9tIHRoZSBVSSdzIGRvbU5vZGUuIEVpdGhlciBhbmltYXRlIHVzaW5nIENTUzMgb3Igb3ZlcnJpZGVcbiAgICAgKiB0aGlzIHRvIGNyZWF0ZSBhIEphdmFzY3JpcHQgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHRvIHJ1biB3aGVuIHRoZSBjbG9zZSBpcyBjb21wbGV0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICBhIHJlZmVyZW5jZSB0byB0aGUgVUkgb2JqZWN0IChmb3IgY2hhaW5pbmcpLlxuICAgICAqL1xuICAgIEJhc2VVSS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGNiKSB7XG4gICAgICAgIHRoaXMuZG9tTm9kZS5yZW1vdmVDbGFzcygnb3BlbicpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICBpZiAoY2IgJiYgZihjYikpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50Tm9kZSBmb3IgYSBVSS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgLmNvbnRlbnQgbm9kZSBvciB0aGUgZG9tTm9kZSBvZiB0aGUgVUkgaW4gcXVlc3Rpb24uXG4gICAgICovXG4gICAgQmFzZVVJLmdldENvbnRlbnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Tm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBtZXRob2RzIHRvIHRoZSBVSSBvYmplY3QgeW91J3JlIGNyZWF0aW5nLiBBdXRvbWF0aWNhbGx5IGNyZWF0ZSBzdXBlciBtZXRob2RzIHdoZW4gdGhlIG9iamVjdCB5b3UncmVcbiAgICAgKiBwYXNzaW5nIGluIGNvbnRhaW5zIHRoZXNhbWUgbWV0aG9kcyBhcyBpdHMgcGFyZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCBjb250YWluaW5nIHRoZSBtZXRob2RzIHlvdSB3aXNoIHRvIGFkZCB0byB0aGUgaG9zdCBvYmplY3QuXG4gICAgICovXG4gICAgQmFzZVVJLmFkZE1ldGhvZHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgbWV0aG9kLCBhcmdzO1xuICAgICAgICBmb3IgKG1ldGhvZCBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShtZXRob2QpICYmIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0gPSBvcHRpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1snc3VwZXInICsgbWV0aG9kXSA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1ttZXRob2RdKGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1snc3VwZXInICsgbWV0aG9kXShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIG9iamVjdCBhbmQgZXh0ZW5kcyBpdCB3aXRoIHRoZSBCYXNlVUlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIGV4dGVuZDtcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGV4dGVuZGVkIG9iamVjdFxuICAgICAqL1xuICAgIEJhc2VVSS5jcmVhdGVVSSA9IEJhc2VVSS5leHRlbmQuY3VycnkodW5kZWZpbmVkLCBCYXNlVUkpO1xuICAgIHJldHVybiBCYXNlVUk7XG59IC8qKlxuICAgKiBAYXV0aG9yIFNjb3R0IHZhbiBMb295XG4gICAqL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBiYXNlVUk7XG5cbn0se1wiLi9TaGFyZWRcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9TaGFyZWQgPSByZXF1aXJlKCcuL1NoYXJlZCcpO1xuXG52YXIgX0FycmF5VXRpbHMgPSByZXF1aXJlKCcuL0FycmF5VXRpbHMnKTtcblxuLyoqXG4gKiBAYXV0aG9yIFNjb3R0IHZhbiBMb295XG4gKi9cblxuLyoqIFBSSVZBVEUgTUVUSE9EUyAqKi9cbmZ1bmN0aW9uIGJhc2VWaWV3KG1peGluKSB7XG4gICAgdmFyIEJhc2VWaWV3ID0gKDAsIF9TaGFyZWQuYXVnbWVudE9iamVjdCkoe30pLFxuICAgICAgICBkZWZhdWx0cyA9IFtdLFxuICAgICAgICBsb2FkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGxvYWRDb21wb25lbnRzKG5hbWVzcGFjZSwgdWlzQXJyYXksIHZpZXcsIGFkZFRvRGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGFyciA9ICgwLCBfQXJyYXlVdGlscy5jb21iaW5lKShkZWZhdWx0cywgdWlzQXJyYXkpLFxuICAgICAgICAgICAgbCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgdmlldyA9IHZpZXcgfHwge307XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIGlmIChhcnJbbF0gJiYgbmFtZXNwYWNlW2FycltsXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZVthcnJbbF1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVthcnJbbF1dID0gbmV3IG5hbWVzcGFjZVthcnJbbF1dKHZpZXcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZVthcnJbbF1dLnNldFZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGRUb0RlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzLnB1c2goYXJyW2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0W2FycltsXV0gPSBuYW1lc3BhY2VbYXJyW2xdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgLyoqIEFQSSBNRVRIT0RTICoqL1xuICAgIC8qKlxuICAgICAqIFNldHMgZGVmYXVsdCBVSXMuIFRoZXNlIFVJcyBhcHBlYXIgb24gZXZlcnkgcGFnZS4gU2hvdWxkIG9ubHkgYmVcbiAgICAgKiBjYWxsZWQgb25jZSBpbiB5b3VyIHByb2plY3QgYXMgaXQgcmVwbGFjZXMgZXZlcnl0aGluZyBlYWNoIHRpbWUuXG4gICAgICogZ2VuZXJhbGx5IHlvdSB3b3VsZCBjYWxsIHRoaXMgZnJvbSB5b3VyIGFwcCB2aWV3LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBucyAtIHRoZSBuYW1lc3BhY2UgeW91ciBVSXMgY2FuIGJlIGZvdW5kIHVuZGVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhcnIgLSBBbiBhcnJheSBvZiBVSSBuYW1lcy5cbiAgICAgKi9cbiAgICBCYXNlVmlldy5zZXREZWZhdWx0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIHNldERlZmF1bHRDb21wb25lbnRzKG5hbWVzcGFjZSwgYXJyKSB7XG4gICAgICAgIGRlZmF1bHRzID0gW107XG4gICAgICAgIHJldHVybiBsb2FkQ29tcG9uZW50cyhuYW1lc3BhY2UsIGFyciwgbnVsbCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBhcnJheSBvZiBkZWZhdWx0IGNvbXBvbmVudHMuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBCYXNlVmlldy5nZXREZWZhdWx0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDb21wb25lbnRzKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbGwgdmlld3MgcmVxdWlyZSBhIHNldCBvZiBjb21wb25lbnRzIHRoYXQgZXhpc3Qgd2l0aGluIHRoYXQgdmlldy4gRXZlcnlcbiAgICAgKiB2aWV3IHNob3VsZCBoYXZlIGFuIGVudGVyIG1ldGhvZCB0aGF0IGNhbGxzIHJlcXVpcmVzIGFuZCBhZGRzIHRoZSBmb2xsb3dpbmcuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBuYW1lc3BhY2UgeW91ciBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gYXJyICAgICAgIGFuIGFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBVSSBjb21wb25lbnQgbmFtZXNcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ1tdfSAgICAgICAgICAgYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAqL1xuICAgIEJhc2VWaWV3LnJlcXVpcmVzID0gZnVuY3Rpb24gcmVxdWlyZXMobmFtZXNwYWNlLCBhcnIsIHZpZXcpIHtcbiAgICAgICAgdmFyIHVpTWFwID0gKDAsIF9BcnJheVV0aWxzLmNvbWJpbmUpKGFyciwgZGVmYXVsdHMpO1xuICAgICAgICB2aWV3LnVpcyA9IGxvYWRDb21wb25lbnRzKG5hbWVzcGFjZSwgdWlNYXAsIHZpZXcpO1xuICAgICAgICByZXR1cm4gdmlldy51aXM7XG4gICAgfTtcbiAgICBCYXNlVmlldy5yb3V0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vd3JpdGUgY29kZVxuICAgIH07XG4gICAgQmFzZVZpZXcuY2FwdHVyZVJvdXRlcyA9IGZ1bmN0aW9uIHJvdXRlcygpIHtcbiAgICAgICAgLy93cml0ZSBjb2RlXG4gICAgfTtcbiAgICBCYXNlVmlldy5jYXB0dXJlRm9ybXMgPSBmdW5jdGlvbiBjYXB0dXJlRm9ybXMoKSB7XG4gICAgICAgIC8vd3JpdGUgY29kZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gb2JqZWN0IGFuZCBleHRlbmRzIGl0IHdpdGggdGhlIEJhc2VWaWV3XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBleHRlbmQ7XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBleHRlbmRlZCBvYmplY3RcbiAgICAgKi9cbiAgICBCYXNlVmlldy5jcmVhdGVWaWV3ID0gQmFzZVZpZXcuZXh0ZW5kLmN1cnJ5KHVuZGVmaW5lZCwgQmFzZVZpZXcpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgd2hlcmUgeW91IGNhbiBmaW5kIGFuIG9iamVjdCByZXByZXNlbnRpbmcgeW91ciBVSXMgb25jZSB5b3UndmUgY2FsbGVkIHJlcXVpcmVzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBCYXNlVmlldy51aXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIgdGhhdCBpbnN0YW50aWF0ZWQgdGhlIHZpZXdcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIEJhc2VWaWV3LmNvbnRyb2xsZXIgPSBudWxsO1xuXG4gICAgcmV0dXJuIEJhc2VWaWV3O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYmFzZVZpZXc7XG5cbn0se1wiLi9BcnJheVV0aWxzXCI6MSxcIi4vU2hhcmVkXCI6OH1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2hhcmVkID0gcmVxdWlyZSgnLi9TaGFyZWQnKTtcblxudmFyIF9CYXNlVUkgPSByZXF1aXJlKCcuL0Jhc2VVSScpO1xuXG52YXIgX0Jhc2VVSTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlVUkpO1xuXG52YXIgX0Jhc2VDb250cm9sbGVyID0gcmVxdWlyZSgnLi9CYXNlQ29udHJvbGxlcicpO1xuXG52YXIgX0Jhc2VDb250cm9sbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Jhc2VDb250cm9sbGVyKTtcblxudmFyIF9CYXNlVmlldyA9IHJlcXVpcmUoJy4vQmFzZVZpZXcnKTtcblxudmFyIF9CYXNlVmlldzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlVmlldyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQGF1dGhvciBTY290dCB2YW4gTG9veVxuICogQG5hbWUgeyBPYmplY3RKUzpbbmFtZV19XG4gKi9cbmZ1bmN0aW9uIG9qcyhvcHRpb25zKSB7XG4gICAgdmFyIGN1cnJlbnRWaWV3ID0gdm9pZCAwLFxuICAgICAgICB2aWV3cyA9IHZvaWQgMCxcbiAgICAgICAgTWl4aW4gPSBvcHRpb25zLk1peGluLFxuICAgICAgICBTZWxlY3RvciA9IE1peGluLlNlbGVjdG9yO1xuXG4gICAgZnVuY3Rpb24gT2JqZWN0SlMobm9kZSkge1xuICAgICAgICByZXR1cm4gU2VsZWN0b3Iobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgVVJMIGZvciBsaWJyYXJ5IHNjcmlwdHMgLSBkZXRlcm1pbmVkIGJ5IHRoZSBsb2NhdGlvbiBvZlxuICAgICAqIG9iamVjdC5taW4/LmpzXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gICAgdmFyIEJBU0VfVVJMID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgdmFyIG0gPSBzW3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBtLnNyYy5yZXBsYWNlKC9bXlxcL10rPyQvLCAnJyk7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHNjcmlwdCBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgc3JjICBocmVmIG9mIHRoZSBzY3JpcHQgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2IgICBjYWxsYmFjayB0byBmaXJlIHVwb24gbG9hZGluZy5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgbG9hZCBTY3JpcHRzIHJlbWFpbmluZyB0byBsb2FkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBsZW4gIFRvdGFsIHNjcmlwdHMgdG8gbG9hZFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBudW0gIFNjcmlwdCBpbmRleFxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgIGVyciAgU29tZXRoaW5nIHRvIGRvIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjLCBjYiwgbG9hZCwgbGVuLCBudW0sIGVycikge1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRlZCgpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlIHx8IC9sb2FkZWR8Y29tcGxldGUvLnRlc3Qoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgbG9hZC0tO1xuICAgICAgICAgICAgICAgIGlmICghbG9hZCAmJiBsZW4gPT09IG51bSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nICYmICFjYi5jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicgJiYgIWVyci5jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICBlcnIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgcy5zcmMgPSBzcmM7XG4gICAgICAgIHMuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgcy5vbmxvYWQgPSBzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGxvYWRlZDtcbiAgICAgICAgcy5vbmVycm9yID0gZXJyb3I7XG4gICAgICAgIE9iamVjdEpTKCdoZWFkJykuYXBwZW5kKHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgbmFtZXNwYWNlLiBJZiB0aGUgbmFtZXNwYWNlIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsXG4gICAgICogYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXEgLSByZXF1ZXN0IGluIHRoZSBmb3JtYXQgb2YgJ215Lm5hbWUuc3BhY2UnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRlc3QgLSB0ZXN0IGZvciBhIG1hbWVzcGFjZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8ZmFsc2V9IFRoZSBuYW1lc3BhY2Ugb3IgZmFsc2UgaWYgdGVzdCBpcyB0cnVlIGFuZCB0aGUgbmFtZXNwYWNlIGRvZXNuJ3QgZXhpc3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXFOYW1lU3BhY2UocmVxLCB0ZXN0KSB7XG4gICAgICAgIHZhciB0LCB4LCB0bnMsIGw7XG4gICAgICAgIGlmICghcmVxIHx8IHR5cGVvZiByZXEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAoMCwgX1NoYXJlZC5lcnIpKCdnZXROYW1lU3BhY2UgZXJyb3IgLSByZXF1aXJlcyBhIHN0cmluZyBpbiB0aGUgZm9ybWF0IFwibXkubmFtZS5zcGFjZVwiJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcS5tYXRjaCgnXFxcXC4nKSkge1xuICAgICAgICAgICAgdCA9IFtyZXFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdCA9IHJlcS5zcGxpdCgnLicpO1xuICAgICAgICB9XG4gICAgICAgIHRucyA9IHdpbmRvdztcbiAgICAgICAgbCA9IHQubGVuZ3RoO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgbDsgeCsrKSB7XG4gICAgICAgICAgICBpZiAodG5zW3RbeF1dKSB7XG4gICAgICAgICAgICAgICAgdG5zID0gdG5zW3RbeF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRucyA9IHRuc1t0W3hdXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0bnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJlcXVpcmVzIG1ldGhvZC4gVXNpbmcgdGhlIGxvY2F0aW9uIG9mIG9iamVjdC5taW4/LmpzIGFzIHRoZSBiYXNlLCBjYW5cbiAgICAgKiBsb2FkIG90aGVyIG1vZHVsZXMuIENoZWNrcyB0byBzZWUgaWYgdGhleSBleGlzdCBhbmQgaWYgdGhleSBkb24ndCwgd2UgZ3JhYlxuICAgICAqIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcmVxdWlyZXMgLSBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBhIGNvbXBvbmVudCdzIHBhdGguXG4gICAgICogJ215YXBwL21haW4vSGVsbG8uanMnIHdvdWxkIGJlIHdyaXR0ZW4gYXMgJ215YXBwLm1haW4uSGVsbG8nIGFuZCBIZWxsby5qc1xuICAgICAqIHdvdWxkIGNvbnRhaW5zIGFuIG9iamVjdCBhdCB0aGUgc2FtZSBuYW1lc3BhY2VcbiAgICAgKiAobXlhcHAubWFpbi5IZWxsbyA9IChmdW5jdGlvbigpe30oKSkpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXS4gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIHdoZW4gbG9hZGluZyBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXF1aXJlcyhyZXF1aXJlcywgY2FsbGJhY2ssIG9qKSB7XG4gICAgICAgIHZhciBsID0gcmVxdWlyZXMubGVuZ3RoLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgbG9hZCA9IDAsXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgZG9jYWxsYmFjayA9IGZhbHNlLFxuICAgICAgICAgICAgbmFtZXNwYWNlVGVzdDtcbiAgICAgICAgb2ogPSBvaiB8fCAnbnMnO1xuICAgICAgICBuYW1lc3BhY2VUZXN0ID0gZnVuY3Rpb24gbmFtZXNwYWNlVGVzdChuYW1lc3BhY2UsIHRlc3QpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgc3RyQXJyID0gdGVzdC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgICAgIGwgPSBzdHJBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHA7XG4gICAgICAgICAgICAvLyBGaW5kIHN0YXJ0aW5nIHBvaW50LiBFaXRoZXIgb3VyIG93biBuYW1lc3BhY2Ugb3IgdGhlIHdpbmRvdy4gSWYgbmVpdGhlciwgcmV0dXJuIGZhbHNlLlxuICAgICAgICAgICAgaWYgKCFyZXRbc3RyQXJyWzBdXSAmJiAhd2luZG93W3N0ckFyclswXV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgc3RhcnRpbmcgcG9pbnQgaXMgdGhlIHdpbmRvdywgc2V0IHdpbmRvdyB0byB0aGUgcmV0dXJuIHZhbHVlLlxuICAgICAgICAgICAgaWYgKCFyZXRbc3RyQXJyWzBdXSAmJiB3aW5kb3dbc3RyQXJyWzBdXSkge1xuICAgICAgICAgICAgICAgIHJldCA9IHdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocCA9IDA7IHAgPCBsOyBwKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0W3N0ckFycltwXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVpcmVzID0gW3JlcXVpcmVzXTtcbiAgICAgICAgICAgIGwgPSByZXF1aXJlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGw7IG4rKykge1xuICAgICAgICAgICAgZG9jYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgc3JjID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VUZXN0KG9qLCByZXF1aXJlc1tuXSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNyYyA9IEJBU0VfVVJMICsgcmVxdWlyZXNbbl0ucmVwbGFjZSgvXFwuL2dpLCAnLycpICsgJy5qcyc7XG4gICAgICAgICAgICAgICAgaWYgKG9qLmZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRTY3JpcHQoc3JjLCBjYWxsYmFjaywgbG9hZCwgcmVxdWlyZXMubGVuZ3RoLCBuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb2NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQud3JpdGUoJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cIicgKyBzcmMgKyAnXCI+PFxcL3NjcmlwdD4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGlzIGl0ZW0uIFJ1biBjYWxsYmFjay5cbiAgICAgICAgICAgICAgICBkb2NhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgIG9iaiB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0IHRvIGluaXRpYWxpc2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgbnMgIHRoZSBuYW1lc3BhY2UgaXQgbGl2ZXMgaW5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmbl0gIEEgZnVuY3Rpb24gdG8gcnVuIG9uIHRoZSBuZXdseSBpbml0aWFsaXNlZCBvYmplY3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBUaGUgbmV3IG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRPYmoob2JqLCBucywgZm4pIHtcbiAgICAgICAgaWYgKCFucyB8fCAhbnNbb2JqXSkge1xuICAgICAgICAgICAgKDAsIF9TaGFyZWQuZXJyKSgnQXR0ZW1wdGVkIHRvIGluaXQgb2JqZWN0Jywgb2JqLCAnaW4gbmFtZXNwYWNlJywgbnMsICdmYWlsZWQuJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5zW29ial0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5zW29ial0gPSBuZXcgbnNbb2JqXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuc1tvYmpdW2ZuXSkge1xuICAgICAgICAgICAgbnNbb2JqXVtmbl0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnNbb2JqXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBhY3RpdmUgdmlldy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGFjdGl2ZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmlldztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSB2aWV3LiBVc2VkIGF0IHRoZSBib3R0b20gb2YgYW4gSFRNTCBwYWdlIHRvIGNhbGwgdGhlIGFzc29jaWF0ZWQgSlMgdmlldyB3aXRoIHRoYXQgcGFnZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZpZXcgVGhlIHZpZXcgbmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZpZXcodmlldykge1xuICAgICAgICBpbml0T2JqKHZpZXcsIHZpZXdzLCAnZW50ZXInKTtcbiAgICAgICAgY3VycmVudFZpZXcgPSB2aWV3c1t2aWV3XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXNlIHRoZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jdXJyeSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5wYXJ0aWFsIHx8IGZ1bmN0aW9uIGN1cnJ5KCkge1xuICAgICAgICAgICAgdmFyIGZuID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgICAgICAgICBsID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGxsID0gbXlBcmdzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxsOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWQucHVzaChteUFyZ3NbaWldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLnB1c2goYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5pdCgpO1xuXG4gICAgdmFyIGJhc2VVSSA9ICgwLCBfQmFzZVVJMi5kZWZhdWx0KShNaXhpbik7XG4gICAgdmFyIGJhc2VDb250cm9sbGVyID0gKDAsIF9CYXNlQ29udHJvbGxlcjIuZGVmYXVsdCkoTWl4aW4pO1xuICAgIHZhciBiYXNlVmlldyA9ICgwLCBfQmFzZVZpZXcyLmRlZmF1bHQpKE1peGluKTtcblxuICAgIE9iamVjdEpTLk5PT1AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBPYmplY3RKUy5yZXFOYW1lU3BhY2UgPSByZXFOYW1lU3BhY2U7XG4gICAgT2JqZWN0SlMucmVxdWlyZXMgPSByZXF1aXJlcztcbiAgICBPYmplY3RKUy5CQVNFX1VSTCA9IEJBU0VfVVJMO1xuICAgIE9iamVjdEpTLmF1Z21lbnRPYmplY3QgPSBfU2hhcmVkLmF1Z21lbnRPYmplY3Q7XG4gICAgT2JqZWN0SlMuaW5pdE9iaiA9IGluaXRPYmo7XG4gICAgT2JqZWN0SlMuZ2V0VmlldyA9IGdldFZpZXc7XG4gICAgT2JqZWN0SlMudmlldyA9IHZpZXc7XG4gICAgT2JqZWN0SlMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG4gICAgT2JqZWN0SlMuZXJyID0gX1NoYXJlZC5lcnI7XG4gICAgT2JqZWN0SlMubG9nID0gX1NoYXJlZC5sb2c7XG4gICAgT2JqZWN0SlMud2FybiA9IF9TaGFyZWQud2FybjtcbiAgICBPYmplY3RKUy5jcmVhdGVVSSA9IGJhc2VVSS5jcmVhdGVVSTtcbiAgICBPYmplY3RKUy5zZXRSb290RG9tTm9kZSA9IGJhc2VVSS5zZXRSb290RG9tTm9kZTtcbiAgICBPYmplY3RKUy5jcmVhdGVWaWV3ID0gYmFzZVZpZXcuY3JlYXRlVmlldztcbiAgICBPYmplY3RKUy5jcmVhdGVDb250cm9sbGVyID0gYmFzZUNvbnRyb2xsZXIuY3JlYXRlQ29udHJvbGxlcjtcbiAgICByZXR1cm4gT2JqZWN0SlM7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9qcztcblxufSx7XCIuL0Jhc2VDb250cm9sbGVyXCI6MixcIi4vQmFzZVVJXCI6MyxcIi4vQmFzZVZpZXdcIjo0LFwiLi9TaGFyZWRcIjo4fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogQGF1dGhvciBzY290dHZhbmxvb3lcbiAqL1xudmFyIE9iamVjdEpTID0gcmVxdWlyZSgnLi9PYmplY3RKUycpO1xuXG52YXIgT0JKTUlYSU5TLFxuICAgIFVJTUlYSU5TLFxuICAgIHRoYXQsXG4gICAgZGF0YU9iaiA9IHt9LFxuICAgIGV2ZW50QmluZCxcbiAgICBldmVudFByZWZpeDtcbmZ1bmN0aW9uIGdldEF0dHIoc3RyLCBhdHRyKSB7XG4gICAgcmV0dXJuIChzdHIuc3BsaXQobmV3IFJlZ0V4cCgnXFxcXGInICsgYXR0ciArICc9JykpWzFdIHx8ICcnKS5zcGxpdCgnJicpWzBdO1xufVxuXG5mdW5jdGlvbiBoaWphY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlIHx8ICFlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZSA9IHtcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IHdpbmRvdy5ldmVudC5jYW5jZWxCdWJibGUsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIE5hdGl2ZVVJKG9iamVjdCkge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBPQkpNSVhJTlMpIHtcbiAgICAgICAgaWYgKE9CSk1JWElOUy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2ldID0gT0JKTUlYSU5TW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBOYXRpdmVTZWxlY3RvcihpZCwgbm9kZSkge1xuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICB0aHJvdyAnT2xkIGJyb3dzZXIsIHBsZWFzZSB1c2UgalF1ZXJ5IG1peGluJztcbiAgICB9XG4gICAgdmFyIE5vZGU7XG4gICAgLy8gSWYgd2UncmUganVzdCBhbiBJRCwgZ2V0IHVzLiBnZXRFbGVtZW50QnlJZCBpcyBmYXN0ZXIgdGhhbiBxdWVyeVNlbGVjdG9yQWxsIC1cbiAgICAvLyB0aGlzIGN1cnJlbnRseSB3b3JrcyBhYm91dCAxMCB0aW1lcyBmYXN0ZXIgdGhhbiBqUXVlcnkgZm9yIHNpbmdsZSBJRHMgYW5kXG4gICAgLy8gbmVhcmx5IHR3aWNlIGFzIGZhc3QgZm9yIG1vcmUgY29tcGxleCBxdWVyaWVzLlxuICAgIGlmIChpZC5jaGFyQXQoMCkgPT09ICcjJyAmJiBpZC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICAgIE5vZGUgPSBbZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQuc3Vic3RyaW5nKDEpKV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgTm9kZSA9ICgobm9kZSB8fCBbXSlbMF0gfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoaWQpO1xuICAgIH1cbiAgICBpZiAoIU5vZGUpIHtcbiAgICAgICAgTm9kZSA9IFtdO1xuICAgIH1cbiAgICBhdWdtZW50KE5vZGUpO1xuICAgIHJldHVybiBOb2RlO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlbGF5KE5vZGVMaXN0LCBjbG9zdXJlKSB7XG4gICAgdmFyIGwsIHJldCwgbm9kZTtcbiAgICBpZiAoIU5vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICBOb2RlTGlzdCA9IFtOb2RlTGlzdF07XG4gICAgfVxuICAgIGwgPSBOb2RlTGlzdC5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcihuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xvc3VyZSgpO1xuICAgICAgICB9LCBuLnRkZWxheSk7XG4gICAgfVxuICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgbm9kZSA9IE5vZGVMaXN0W2xdO1xuICAgICAgICBpZiAobm9kZS50ZGVsYXkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS50dGltZXJzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS50dGltZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnR0aW1lcnMucHVzaChyKG5vZGUpKTtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldCA/IGF1Z21lbnQoTm9kZUxpc3QpIDogY2xvc3VyZSgpO1xufVxuXG5mdW5jdGlvbiBOYXRpdmVDb250cm9sbGVyKENvbnRyb2xsZXIpIHtcbiAgICBDb250cm9sbGVyLmNyZWF0ZVhIUiA9IGZ1bmN0aW9uIGNyZWF0ZVhIUigpIHtcbiAgICAgICAgdmFyIHhocjtcbiAgICAgICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgeGhyID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ01TWE1MMi5YTUxIVFRQLjMuMCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIENvbnRyb2xsZXIuY3JlYXRlSlNPTlAgPSBmdW5jdGlvbiBjcmVhdGVKU09OUChjYm5hbWUpIHtcbiAgICAgICAgdmFyIGZuID0gdHlwZW9mIGNibmFtZSA9PT0gJ3N0cmluZycgPyBjYm5hbWUgOiAnZicgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygxNiksXG4gICAgICAgICAgICBKU09OUCA9IHt9O1xuICAgICAgICBKU09OUC5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgdXJsID0gb3B0aW9ucy51cmwsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvcHRpb25zLmVycm9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID4gMTAwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdEaWRuXFwndCBnZXQgYW55IGRhdGEgYWZ0ZXIgMTBzLCBjaGVjayA/Y2FsbGJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFPYmpbZm5dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YU9ialtmbl0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBnZXRBdHRyKHVybCwgJ2NhbGxiYWNrJyk7XG4gICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgIGZuID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9ICc/Y2FsbGJhY2snO1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignPycpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjID0gJyZjYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybCArPSBjICsgJz0nICsgZm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3dbZm5dID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhT2JqW2ZuXSA9IGRhdGE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBPYmplY3RKUy5sb2FkU2NyaXB0KHVybCwgY2IsIDEsIDAsIDAsIGVycm9yKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBKU09OUC5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vc29tZXRoaW5nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKU09OUDtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXVnbWVudChOb2Rlcykge1xuICAgIHZhciBpO1xuICAgIGlmICghTm9kZXMuYXVnbWVudGVkKSB7XG4gICAgICAgIGZvciAoaSBpbiBVSU1JWElOUykge1xuICAgICAgICAgICAgaWYgKFVJTUlYSU5TLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgTm9kZXNbaV0gPSBVSU1JWElOU1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBOb2Rlcy5hdWdtZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZXM7XG59XG5PQkpNSVhJTlMgPSB7XG4gICAgc3VwZXJPcGVuOiBmdW5jdGlvbiBzdXBlck9wZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhhdCA9IHRoYXQgfHwgdGhpcztcbiAgICAgICAgdGhhdC5kb21Ob2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjaygpIDogbnVsbDtcbiAgICB9LFxuICAgIHN1cGVyQ2xvc2U6IGZ1bmN0aW9uIHN1cGVyQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhhdCA9IHRoYXQgfHwgdGhpcztcbiAgICAgICAgdGhhdC5kb21Ob2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKCkgOiBudWxsO1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICB0aGF0ID0gdGhhdCB8fCB0aGlzO1xuICAgICAgICB0aGF0LmRvbU5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uIG9mZigpIHtcbiAgICAgICAgdGhhdCA9IHRoYXQgfHwgdGhpcztcbiAgICAgICAgdGhhdC5kb21Ob2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufTtcblVJTUlYSU5TID0ge1xuICAgIGluaXQ6IHRydWUsXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChzdHIpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBubCxcbiAgICAgICAgICAgIG5sbCxcbiAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgICAgIH1cbiAgICAgICAgbCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgbmwgPSBOYXRpdmVTZWxlY3RvcihzdHIsIG5vZGVzW2xdKTtcbiAgICAgICAgICAgIG5sbCA9IG5sLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChubGwtLSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKG5sW25sbF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdWdtZW50KHJldCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgdmFyIE5vZGVMaXN0ID0gdGhpcyxcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgbCA9IE5vZGVMaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgIG47XG4gICAgICAgIHJldHVybiBjaGVja0RlbGF5KE5vZGVMaXN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIU5vZGVMaXN0Lml0ZW0gJiYgIUFycmF5LmlzQXJyYXkoTm9kZUxpc3QpKSB7XG4gICAgICAgICAgICAgICAgTm9kZUxpc3QgPSBbTm9kZUxpc3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGw7IG4rKykge1xuICAgICAgICAgICAgICAgIE5vZGVMaXN0W25dLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoTm9kZUxpc3Rbbl0pO1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGF1Z21lbnQoTm9kZUxpc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdWdtZW50KHJldCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYmluZDogZnVuY3Rpb24gYmluZChzdHIsIGZ1bmMpIHtcbiAgICAgICAgdmFyIE5vZGVMaXN0ID0gdGhpcyxcbiAgICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIG47XG4gICAgICAgIHJldHVybiBjaGVja0RlbGF5KE5vZGVMaXN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIU5vZGVMaXN0Lml0ZW0pIHtcbiAgICAgICAgICAgICAgICBOb2RlTGlzdCA9IFtOb2RlTGlzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsID0gTm9kZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFldmVudEJpbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoTm9kZUxpc3RbMF0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBldmVudEJpbmQgPSAnYWRkRXZlbnRMaXN0ZW5lcic7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRCaW5kID0gJ2F0dGFjaEV2ZW50JztcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRQcmVmaXggPSAnb24nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTm9kZUxpc3Rbbl1bZXZlbnRCaW5kXSkge1xuICAgICAgICAgICAgICAgICAgICBOb2RlTGlzdFtuXVtldmVudEJpbmRdKGV2ZW50UHJlZml4ICsgc3RyLCBoaWphY2soZnVuYyksIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXQucHVzaChhdWdtZW50KE5vZGVMaXN0W25dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc05hbWVzKSB7XG4gICAgICAgIHZhciBOb2RlID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gcChvLCBjKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG8gfHwgJycsXG4gICAgICAgICAgICAgICAgcGEsXG4gICAgICAgICAgICAgICAgbCxcbiAgICAgICAgICAgICAgICBpYSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBpYSA9IGUuaW5kZXhPZignICcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBjaWEgPSBjLmluZGV4T2YoJyAnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgY3M7XG4gICAgICAgICAgICBpZiAocGlhIHx8IGNpYSkge1xuICAgICAgICAgICAgICAgIGlmIChwaWEgJiYgY2lhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3RKUy5jb3JlLnV0aWxzLkFycmF5VXRpbHMuY29tYmluZShlLnNwbGl0KCcgJyksIGMuc3BsaXQoJyAnKSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYSA9IHBpYSA/IGUuc3BsaXQoJyAnKSA6IGMuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICBjcyA9IHBpYSA/IGMgOiBlO1xuICAgICAgICAgICAgICAgIGwgPSBwYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFbbF0gPT09IGNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpYSAmJiBjcyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGEucHVzaChjcy50cmltID8gY3MudHJpbSgpIDogY3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGEuam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGUgPT09ICcnID8gYyA6IGUgKyAnICcgKyBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja0RlbGF5KE5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChOb2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gTm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwtLSAmJiBOb2RlW2xdLnNldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBOb2RlW2xdLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBwKE5vZGVbbF0uZ2V0QXR0cmlidXRlKCdjbGFzcycpLCBjbGFzc05hbWVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChOb2RlLnNldEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIE5vZGUuc2V0QXR0cmlidXRlKCdjbGFzcycsIHAoTm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksIGNsYXNzTmFtZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdWdtZW50KE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbW9yZSB0aGFuIG9uZSBjbGFzc1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgdmFyIE5vZGUgPSB0aGlzLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGw7XG4gICAgICAgIGlmICghTm9kZS5pdGVtKSB7XG4gICAgICAgICAgICBOb2RlID0gW05vZGVdO1xuICAgICAgICB9XG4gICAgICAgIGwgPSBOb2RlLmxlbmd0aDtcbiAgICAgICAgZnVuY3Rpb24gZChvLCBzKSB7XG4gICAgICAgICAgICBvLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBzLnRyaW0gPyBvLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5yZXBsYWNlKHMsICcnKS50cmltKCkgOiBvLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5yZXBsYWNlKHMsICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbShvLCBjbikge1xuICAgICAgICAgICAgdmFyIGNhID0gY24uc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBjbCA9IGNhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjbC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGQobywgY2FbY2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQobywgY24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHIobikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBtKG4sIGNsYXNzTmFtZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgICAgICBub2RlID0gTm9kZVtsXTtcbiAgICAgICAgICAgIHJldCA9IGNoZWNrRGVsYXkobm9kZSwgcihub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGU7XG4gICAgfSxcbiAgICBzZXRDbGFzczogZnVuY3Rpb24gc2V0Q2xhc3MoY2xhc3NOYW1lcykge1xuICAgICAgICB2YXIgTm9kZSA9IHRoaXMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgbDtcbiAgICAgICAgaWYgKCFOb2RlLml0ZW0pIHtcbiAgICAgICAgICAgIE5vZGUgPSBbTm9kZV07XG4gICAgICAgIH1cbiAgICAgICAgbCA9IE5vZGUubGVuZ3RoO1xuICAgICAgICBmdW5jdGlvbiByKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4uc2V0QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG4uc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZXMudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlW2xdO1xuICAgICAgICAgICAgcmV0ID0gY2hlY2tEZWxheShub2RlLCByKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9kZTtcbiAgICB9LFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBuID0gdGhpcyxcbiAgICAgICAgICAgIGw7XG4gICAgICAgIGlmICghbCkge1xuICAgICAgICAgICAgbiA9IFt0aGlzXTtcbiAgICAgICAgfVxuICAgICAgICBsID0gbi5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuW2ldLmNsYXNzTmFtZSAmJiBuW2ldLmNsYXNzTmFtZS5zcGxpdCAmJiBuW2ldLmNsYXNzTmFtZS5zcGxpdCgnICcpLmluZGV4T2YoY2xhc3NOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiBodG1sKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIE5vZGUgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY2hlY2tEZWxheShOb2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gTm9kZS5sZW5ndGggPyBOb2RlWzBdIDogTm9kZTtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0LmlubmVySFRNTCAmJiByZXQuaW5uZXJIVE1MLnRyaW0gPyByZXQuaW5uZXJIVE1MLnRyaW0oKSA6IHJldC5pbm5lckhUTUw7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcmFuZG9tRGVsYXk6IGZ1bmN0aW9uIHJhbmRvbURlbGF5KG51bWJlcikge1xuICAgICAgICB2YXIgTm9kZSA9IHRoaXMsXG4gICAgICAgICAgICBpbnRuLFxuICAgICAgICAgICAgbDtcbiAgICAgICAgaWYgKCFOb2RlLml0ZW0pIHtcbiAgICAgICAgICAgIGludG4gPSBbTm9kZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRuID0gTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBsID0gaW50bi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIGF1Z21lbnQoaW50bltsXSkuZGVsYXkoTWF0aC5yYW5kb20oKSAqIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGU7XG4gICAgfSxcbiAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkobnVtYmVyKSB7XG4gICAgICAgIHZhciBOb2RlID0gdGhpcyxcbiAgICAgICAgICAgIGludG4sXG4gICAgICAgICAgICBsO1xuICAgICAgICBpZiAoIU5vZGUuaXRlbSkge1xuICAgICAgICAgICAgaW50biA9IFtOb2RlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludG4gPSBOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGwgPSBpbnRuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgaWYgKCFpbnRuW2xdLnRkZWxheSkge1xuICAgICAgICAgICAgICAgIGludG5bbF0udGRlbGF5ID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludG5bbF0udGRlbGF5ICs9IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlO1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgICAgdmFyIE5vZGUgPSB0aGlzLFxuICAgICAgICAgICAgbDtcbiAgICAgICAgaWYgKCFOb2RlLml0ZW0pIHtcbiAgICAgICAgICAgIE5vZGUgPSBbTm9kZV07XG4gICAgICAgIH1cbiAgICAgICAgbCA9IE5vZGUubGVuZ3RoO1xuICAgICAgICBpZiAoIU5vZGVbMF0uc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgICAgIE5vZGVbbF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOb2RlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICB2YXIgTm9kZSA9IHRoaXMsXG4gICAgICAgICAgICBsO1xuICAgICAgICBpZiAoIU5vZGUuaXRlbSkge1xuICAgICAgICAgICAgTm9kZSA9IFtOb2RlXTtcbiAgICAgICAgfVxuICAgICAgICBsID0gTm9kZS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgICAgIE5vZGVbbF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBVSTogTmF0aXZlVUksXG4gICAgU2VsZWN0b3I6IE5hdGl2ZVNlbGVjdG9yLFxuICAgIENvbnRyb2xsZXI6IE5hdGl2ZUNvbnRyb2xsZXJcbn07XG5cbn0se1wiLi9PYmplY3RKU1wiOjd9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX05hdGl2ZSA9IHJlcXVpcmUoJy4vTmF0aXZlJyk7XG5cbnZhciBfTmF0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX05hdGl2ZSk7XG5cbnZhciBfQ29yZSA9IHJlcXVpcmUoJy4vQ29yZScpO1xuXG52YXIgX0NvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIE9iamVjdEpTKCkge1xuICAgIHZhciBjb3JlID0gbmV3IF9Db3JlMi5kZWZhdWx0KHtcbiAgICAgICAgTWl4aW46IF9OYXRpdmUyLmRlZmF1bHRcbiAgICB9KTtcbiAgICBpZiAod2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5PYmplY3RKUyA9IGNvcmU7XG4gICAgfVxuICAgIHJldHVybiBjb3JlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gT2JqZWN0SlMoKTtcblxufSx7XCIuL0NvcmVcIjo1LFwiLi9OYXRpdmVcIjo2fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogSWYgdGhlIHN0cmluZyBcImRlYnVnXCIgYXBwZWFycyBpbiB0aGUgVVJMLCB3ZSB3cml0ZSB0byB0aGUgY29uc29sZSBpZiB0aGVyZSBpcyBvbmVcbiAqIHdoYXRldmVyIHdlIGZlZWQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBlcnIoKSB7XG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiA9PT0gJ2RlYnVnJykge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogSWYgdGhlIHN0cmluZyBcImRlYnVnXCIgYXBwZWFycyBpbiB0aGUgVVJMLCB3ZSB3cml0ZSB0byB0aGUgY29uc29sZSBpZiB0aGVyZSBpcyBvbmVcbiAqIHdoYXRldmVyIHdlIGZlZWQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBsb2coKSB7XG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdkZWJ1ZycpICE9PSAtMSkge1xuICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIElmIHRoZSBzdHJpbmcgXCJkZWJ1Z1wiIGFwcGVhcnMgaW4gdGhlIFVSTCwgd2Ugd3JpdGUgdG8gdGhlIGNvbnNvbGUgaWYgdGhlcmUgaXMgb25lXG4gKiB3aGF0ZXZlciB3ZSBmZWVkIGludG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2FybigpIHtcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ2RlYnVnJykgIT09IC0xKSB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLndhcm4oYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQXVnbWVudCB0aGUgb2JqZWN0LCBhZGRpbmcgYSBmZXcgc2hhcmVkIG1ldGhvZHMgdG8gaXQuXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIGJlIGF1Z21lbnRlZFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgYXVnbWVudGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYXVnbWVudE9iamVjdChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZXJyKCd0cmllZCB0byBhdWdtZW50Jywgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghb2JqZWN0LmF1Z21lbnRlZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIGFuIG9iamVjdCB3aXRoIGFub3RoZXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaXRlbSAgICAgICBjaGlsZCBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbnxPYmplY3R9IEluaGVyaXRhbnQgcGFyZW50IGZ1bmN0aW9uL29iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgUmV0dXJucyB0aGUgb2JqZWN0IHdpdGggaXRzIGF1Z21lbnRhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgb2JqZWN0LmV4dGVuZCA9IG9iamVjdC5leHRlbmQgfHwgZnVuY3Rpb24gZXh0ZW5kKENoaWxkLCBQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQ2hpbGQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBQYXJlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZXJyKCdUcmllZCB0byBleHRlbmQnLCBDaGlsZCwgJ3dpdGgnLCBQYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQYXJlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgQ2hpbGQuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gUGFyZW50O1xuICAgICAgICAgICAgICAgIENoaWxkLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG9iamVjdC5hdWdtZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuZXhwb3J0cy5hdWdtZW50T2JqZWN0ID0gYXVnbWVudE9iamVjdDtcbmV4cG9ydHMuZXJyID0gZXJyO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuXG59LHt9XX0se30sWzddKTtcbiJdLCJmaWxlIjoib2JqZWN0anMubWluLmpzIn0=
