(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

/**
 * @author Scott van Looy
 */

/**
 * takes two arrays of strings and combines them, removing duplicates
 * @method combine
 * @param  {Array} arr1 first array to combine
 * @param  {Array} arr2 second array to combine
 * @return {Array}      deduped unsorted array of strings
 */

function combine(arr1, arr2) {
    var tarr = arr1.concat(arr2),
        l = tarr.length,
        o = {},
        ret = [],
        n,
        name;
    for (n = 0; n < l; n++) {
        o[tarr[n]] = true;
    }
    for (name in o) {
        if (o.hasOwnProperty(name)) {
            ret.push(name);
        }
    }
    return ret;
}
/**
 * returns true if we are an array.
 * @method isArray
 * @param  {Array}  o [description]
 * @return {Boolean}   [description]
 */

function isArray(o) {
    return Array.isArray(o);
}

exports.combine = combine;
exports.isArray = isArray;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

function baseController(mixin) {
    /** PRIVATE METHODS **/
    var BaseController = (0, _Shared.augmentObject)({});

    /** API METHODS **/
    /**
     * On enter of your child controller, you call the view associated with that controller
     * using the callView method. It either instantiates the view or if it already exists
     * it calls "enter" on it. Your view's init must also call enter
     * @param  {Object} namespace your namespace
     * @param  {string} view      the name of the view you're calling.
     * @return {Object}           returns the instantiated view.
     */
    BaseController.callView = function callView(namespace, view) {
        if (typeof namespace === 'undefined' || typeof view === 'undefined') {
            BaseController.err('tried to call', view, 'on ', namespace, 'namespace');
            return null;
        }
        if (typeof namespace[view] === 'function') {
            namespace[view] = new namespace[view]();
            namespace[view].controller = this;
            this.view = namespace[view];
        } else {
            namespace[view].enter();
        }
        return namespace[view];
    };
    /**
     * removes tokens in a string and replaces them with values.
     * @param  {string} string  the string to replace tokens in:
     * in the format of "this is my/{token1}-{token2}/string/{token-3}"
     * @param  {Object} tokens an object of tokens to replace:
     * {
     *   token1: 'bert',
     *   token2: 'fred',
     *   token3: 12
     * }
     * @return {string}         tokenised string.
     */
    BaseController.tokeniser = function tokeniser(string, tokens) {
        if (typeof string === 'undefined' || typeof tokens === 'undefined') {
            BaseController.err('tried to tokenise', string, 'with ', tokens);
            return null;
        }
        var token;
        for (token in tokens) {
            if (tokens.hasOwnProperty(token)) {
                string = string.split('{' + token + '}').join(tokens[token]);
            }
        }
        return string;
    };
    /**
     * getData - gets DATA from an external resource using JSON/JSONP. Will POST
     * for JSON requests, can only GET for JSONP. Technically, JSONP is insecure,
     * be very careful when using it, make sure the 3rd party is trustworthy.
     * @param  {Object} options an object containing the information you require.
     *
     * <pre>
     * {
     *   url:{string}          the URL we get the data from. If JSONP, should either
     *                         include ?callback= parameter for services that don't
     *                         allow dynamic callback assignments, or be callback
     *                         parameter free to allow this code to assign one.
     *
     *   data:{string},        name value pairs
     *
     *   success:{function()}, callback function on success. This will be passed
     *                         a data object.
     *
     *   error:{function()},   callback function to do something on error. This will
     *                         be passed an object representing the error.
     *
     *   jsonp:{string}        when set, forces JSONP with the specified string as callback name
     * }
     *
     * </pre>
     */
    BaseController.getData = function getData(options) {
        var xhr;
        if (options.url && typeof options.url === 'string') {
            if (!BaseController.createXHR || !BaseController.createJSONP) {
                mixin.Controller(BaseController);
            }
            // If we're on the same domain, we need to do an XHR request, if not we do a JSONP.
            if (options.url.indexOf('://') === -1 || options.url.match(window.location.protocol) && options.url.indexOf(window.location.host) !== -1 && !options.jsonp) {
                xhr = BaseController.createXHR();
            } else {
                xhr = BaseController.createJSONP(options.jsonp || true);
            }
            xhr.open(options);
        }
    };
    BaseController.createController = BaseController.extend.curry(undefined, BaseController);
    return BaseController;
}
/**
 * @author Scott van Looy
 */

exports.default = baseController;

},{"./Shared":7}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

function baseUI(mixin) {

    var BaseUI = (0, _Shared.augmentObject)({});

    function f(fn) {
        return typeof fn === 'function';
    }

    /** API METHODS **/
    /**
     * Sets the root dom node that the library uses to find other dom nodes when generating UI components. Defaults to body.
     * @param {String|Object} domNode the selector for the domNode
     */
    BaseUI.setRootDomNode = function setRootDomNode(domNode) {
        BaseUI.root = mixin.Selector(domNode);
    };
    /**
     * Sets up a UI, caches its domnode and prepares it for use.
     * @param {String|Object} id - the dom ID, className or jQuery object of the root element for the UI.
     */
    BaseUI.setupUI = function setupUI(id) {
        var self = this;
        function setup() {
            self.domNode = BaseUI.root ? BaseUI.root.find(id) : mixin.Selector(id);
            self.contentNode = self.domNode.find('.content');
            self.titleNode = self.domNode.find('.title');
            self.templateNode = self.domNode.find('.template').remove();
            self.footerNode = self.domNode.find('.footer');
        }
        if (!self.init) {
            mixin.UI(self);
        }
        setup();
    };
    /**
     * Sets the active view on a UI object
     * @param {Object} view a reference to the view we wish to set on the UI object.
     */
    BaseUI.setView = function setView(view) {
        this.view = view;
    };
    /**
     * Gets a reference to the currently set view on a UI object
     * @return {Object} a reference to the currently set view
     */
    BaseUI.getView = function getView() {
        return this.view;
    };
    /**
     *
     * Opens a UI object. Adds a class of "open" to the UI's domNode. Either animate using CSS3
     * or override this to create a Javascript animation.
     * @param  {Object} obj A reference to the UI object
     * @return {Object}     a reference to the UI object (for chaining).
     */
    BaseUI.open = function open(obj) {
        obj = obj || this;
        obj.domNode.addClass('open');
        obj.isOpen = true;
        return obj;
    };
    /**
     * Closes a UI object. Removes the class "open" from the UI's domNode. Either animate using CSS3 or override
     * this to create a Javascript animation.
     * @param  {Function} [cb] Callback to run when the close is complete.
     * @return {Object}     a reference to the UI object (for chaining).
     */
    BaseUI.close = function close(cb) {
        this.domNode.removeClass('open');
        this.isOpen = false;
        if (cb && f(cb)) {
            cb();
        }
        return this;
    };
    /**
     * Returns the contentNode for a UI.
     * @return {Object} a .content node or the domNode of the UI in question.
     */
    BaseUI.getContentNode = function () {
        return this.contentNode;
    };
    /**
     * Add methods to the UI object you're creating. Automatically create super methods when the object you're
     * passing in contains thesame methods as its parent.
     * @param {Object} options Object containing the methods you wish to add to the host object.
     */
    BaseUI.addMethods = function (options) {
        var method, args;
        for (method in options) {
            if (options.hasOwnProperty(method) && typeof method === 'function') {
                if (!this[method]) {
                    this[method] = options[method];
                } else {
                    options['super' + method] = this[method];
                    this[method] = function () {
                        if (arguments.length === 1) {
                            args = arguments[0];
                        } else {
                            args = arguments;
                        }
                        options[method](args);
                        options['super' + method](args);
                    };
                }
            }
        }
    };
    /**
     * Takes an object and extends it with the BaseUI
     * @param {Object} object to extend;
     * @return {Object} extended object
     */
    BaseUI.createUI = BaseUI.extend.curry(undefined, BaseUI);
    return BaseUI;
} /**
   * @author Scott van Looy
   */

exports.default = baseUI;

},{"./Shared":7}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

var _ArrayUtils = require('./ArrayUtils');

/**
 * @author Scott van Looy
 */

/** PRIVATE METHODS **/
function baseView(mixin) {
    var BaseView = (0, _Shared.augmentObject)({}),
        defaults = [],
        loadComponents = function loadComponents(namespace, uisArray, view, addToDefaults) {
        var arr = (0, _ArrayUtils.combine)(defaults, uisArray),
            l = arr.length,
            ret = {};
        view = view || {};
        while (l--) {
            if (arr[l] && namespace[arr[l]]) {
                if (typeof namespace[arr[l]] === 'function') {
                    namespace[arr[l]] = new namespace[arr[l]](view);
                } else {
                    namespace[arr[l]].setView(view);
                }
                if (addToDefaults) {
                    defaults.push(arr[l]);
                }
                ret[arr[l]] = namespace[arr[l]];
            }
        }
        return ret;
    };
    /** API METHODS **/
    /**
     * Sets default UIs. These UIs appear on every page. Should only be
     * called once in your project as it replaces everything each time.
     * generally you would call this from your app view.
     * @param {Object} ns - the namespace your UIs can be found under.
     * @param {String} arr - An array of UI names.
     */
    BaseView.setDefaultComponents = function setDefaultComponents(namespace, arr) {
        defaults = [];
        return loadComponents(namespace, arr, null, true);
    };
    /**
     * returns the array of default components.
     * @return {Array} [description]
     */
    BaseView.getDefaultComponents = function getDefaultComponents() {
        return defaults;
    };
    /**
     * All views require a set of components that exist within that view. Every
     * view should have an enter method that calls requires and adds the following.
     * @param  {Object} namespace your namespace
     * @param  {String[]} arr       an array of strings containing UI component names
     * @param  {Object}                a reference to the view object
     * @return {String[]}           array of objects
     */
    BaseView.requires = function requires(namespace, arr, view) {
        var uiMap = (0, _ArrayUtils.combine)(arr, defaults);
        view.uis = loadComponents(namespace, uiMap, view);
        return view.uis;
    };
    BaseView.routes = function () {
        //write code
    };
    BaseView.captureRoutes = function routes() {
        //write code
    };
    BaseView.captureForms = function captureForms() {
        //write code
    };
    /**
     * Takes an object and extends it with the BaseView
     * @param {Object} object to extend;
     * @return {Object} extended object
     */
    BaseView.createView = BaseView.extend.curry(undefined, BaseView);
    /**
     * This is where you can find an object representing your UIs once you've called requires
     * @type {Object}
     */
    BaseView.uis = null;
    /**
     * This is a reference to the controller that instantiated the view
     * @type {Object}
     */
    BaseView.controller = null;

    return BaseView;
}
exports.default = baseView;

},{"./ArrayUtils":1,"./Shared":7}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Shared = require('./Shared');

var _BaseUI = require('./BaseUI');

var _BaseUI2 = _interopRequireDefault(_BaseUI);

var _BaseController = require('./BaseController');

var _BaseController2 = _interopRequireDefault(_BaseController);

var _BaseView = require('./BaseView');

var _BaseView2 = _interopRequireDefault(_BaseView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @author Scott van Looy
 * @name { ObjectJS:[name]}
 */
function ojs(options) {
    var currentView = void 0,
        views = void 0,
        Mixin = options.Mixin,
        Selector = Mixin.Selector;

    function ObjectJS(node) {
        return Selector(node);
    }

    /**
     * The base URL for library scripts - determined by the location of
     * object.min?.js
     * @return {string}
     */

    var BASE_URL = function () {
        if (!document) {
            return null;
        }
        var s = document.getElementsByTagName('script');
        var m = s[s.length - 1];
        return m.src.replace(/[^\/]+?$/, '');
    }();

    /**
     * Load a script asynchronously.
     * @param  {string}   src  href of the script to load.
     * @param  {Function} cb   callback to fire upon loading.
     * @param  {Number}   load Scripts remaining to load.
     * @param  {Number}   len  Total scripts to load
     * @param  {Number}   num  Script index
     * @param  {Function}   err  Something to do on error.
     */
    function loadScript(src, cb, load, len, num, err) {

        function loaded() {
            var state = s.state;
            if (!state || /loaded|complete/.test(state)) {
                load--;
                if (!load && len === num) {
                    if (cb && typeof cb === 'function' && !cb.called) {
                        cb.call(this);
                        cb.called = true;
                    }
                }
            }
        }

        function error() {
            if (err && typeof err === 'function' && !err.called) {
                err.call(this);
                err.called = true;
            }
        }
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = src;
        s.async = false;
        s.onload = s.onreadystatechange = loaded;
        s.onerror = error;
        ObjectJS('head').append(s);
    }

    /**
     * Requests a namespace. If the namespace does not exist, it will
     * be created
     * @param {String} req - request in the format of 'my.name.space'
     * @param {Object} test - test for a mamespace.
     * @return {Object|false} The namespace or false if test is true and the namespace doesn't exist
     */
    function reqNameSpace(req, test) {
        var t, x, tns, l;
        if (!req || typeof req !== 'string') {
            (0, _Shared.err)('getNameSpace error - requires a string in the format "my.name.space"');
            return null;
        }
        if (!req.match('\\.')) {
            t = [req];
        } else {
            t = req.split('.');
        }
        tns = window;
        l = t.length;
        for (x = 0; x < l; x++) {
            if (tns[t[x]]) {
                tns = tns[t[x]];
            } else {
                if (test) {
                    return false;
                }
                tns = tns[t[x]] = {};
            }
        }
        return tns;
    }
    /**
     * requires method. Using the location of object.min?.js as the base, can
     * load other modules. Checks to see if they exist and if they don't, we grab
     * the module.
     * @param {Array} requires - array of strings representing a component's path.
     * 'myapp/main/Hello.js' would be written as 'myapp.main.Hello' and Hello.js
     * would contains an object at the same namespace
     * (myapp.main.Hello = (function(){}()))
     * @param {Function} [callback]. Optional callback to run when loading is complete.
     */
    function requires(requires, callback, oj) {
        var l = requires.length,
            src,
            load = 0,
            n,
            docallback = false,
            namespaceTest;
        oj = oj || 'ns';
        namespaceTest = function namespaceTest(namespace, test) {
            var ret = namespace,
                strArr = test.split('.'),
                l = strArr.length,
                p;
            // Find starting point. Either our own namespace or the window. If neither, return false.
            if (!ret[strArr[0]] && !window[strArr[0]]) {
                return undefined;
            }
            // If starting point is the window, set window to the return value.
            if (!ret[strArr[0]] && window[strArr[0]]) {
                ret = window;
            }
            for (p = 0; p < l; p++) {
                if (ret !== undefined) {
                    ret = ret[strArr[p]];
                }
            }
            return ret;
        };
        if (typeof requires === 'string') {
            requires = [requires];
            l = requires.length;
        }
        for (n = 0; n < l; n++) {
            docallback = false;
            src = null;
            if (namespaceTest(oj, requires[n]) === undefined) {
                src = BASE_URL + requires[n].replace(/\./gi, '/') + '.js';
                if (oj.finished) {
                    loadScript(src, callback, load, requires.length, n);
                } else {
                    docallback = true;
                    document.write('<script type="text/javascript" src="' + src + '"><\/script>');
                }
            } else {
                // We already have this item. Run callback.
                docallback = true;
            }
        }
        if (docallback) {
            if (callback) {
                callback();
            }
        }
    }

    /**
     * Initialise an object
     * @param  {String}   obj the name of the object to initialise
     * @param  {Object}   ns  the namespace it lives in
     * @param  {String} [fn]  A function to run on the newly initialised object.
     * @return {Object}       The new object
     */
    function initObj(obj, ns, fn) {
        if (!ns || !ns[obj]) {
            (0, _Shared.err)('Attempted to init object', obj, 'in namespace', ns, 'failed.');
            return null;
        }
        if (typeof ns[obj] === 'function') {
            ns[obj] = new ns[obj]();
        }
        if (ns[obj][fn]) {
            ns[obj][fn]();
        }
        return ns[obj];
    }
    /**
     * Returns a reference to the current active view.
     * @return {Object} a reference to the current active view.
     */
    function getView() {
        return currentView;
    }
    /**
     * Calls a view. Used at the bottom of an HTML page to call the associated JS view with that page.
     * @param  {String} view The view name
     */
    function view(view) {
        initObj(view, views, 'enter');
        currentView = views[view];
    }

    /**
     * initialise the object
     * @private
     */
    function init() {
        Function.prototype.curry = Function.prototype.partial || function curry() {
            var fn = this,
                args = Array.prototype.slice.call(arguments);
            return function () {
                var myArgs = Array.prototype.slice.call(arguments),
                    combined = [];
                var i,
                    ii,
                    l = args.length,
                    ll = myArgs.length;
                for (i = 0; i < l; i++) {
                    if (args[i] === undefined) {
                        for (ii = 0; ii < ll; ii++) {
                            combined.push(myArgs[ii]);
                        }
                    } else {
                        combined.push(args[i]);
                    }
                }
                return fn.apply(this, combined);
            };
        };
    }

    init();

    var baseUI = (0, _BaseUI2.default)(Mixin);
    var baseController = (0, _BaseController2.default)(Mixin);
    var baseView = (0, _BaseView2.default)(Mixin);

    ObjectJS.NOOP = function () {};
    ObjectJS.reqNameSpace = reqNameSpace;
    ObjectJS.requires = requires;
    ObjectJS.BASE_URL = BASE_URL;
    ObjectJS.augmentObject = _Shared.augmentObject;
    ObjectJS.initObj = initObj;
    ObjectJS.getView = getView;
    ObjectJS.view = view;
    ObjectJS.loadScript = loadScript;
    ObjectJS.err = _Shared.err;
    ObjectJS.log = _Shared.log;
    ObjectJS.warn = _Shared.warn;
    ObjectJS.createUI = baseUI.createUI;
    ObjectJS.setRootDomNode = baseUI.setRootDomNode;
    ObjectJS.createView = baseView.createView;
    ObjectJS.createController = baseController.createController;
    return ObjectJS;
}

exports.default = ojs;

},{"./BaseController":2,"./BaseUI":3,"./BaseView":4,"./Shared":7}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _jQuery = require('./jQuery');

var _jQuery2 = _interopRequireDefault(_jQuery);

var _Core = require('./Core');

var _Core2 = _interopRequireDefault(_Core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ObjectJS() {
    var core = new _Core2.default({
        Mixin: _jQuery2.default
    });
    if (window) {
        window.ObjectJS = core;
    }
    return core;
}
exports.default = ObjectJS();

},{"./Core":5,"./jQuery":8}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function err() {
    if (window && window.console && window.location.href === 'debug') {
        window.console.error(arguments);
    }
    return true;
}
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function log() {
    if (window && window.console && window.location.href.indexOf('debug') !== -1) {
        window.console.log(arguments);
    }
    return true;
}
/**
 * If the string "debug" appears in the URL, we write to the console if there is one
 * whatever we feed into this function.
 */
function warn() {
    if (window && window.console && window.location.href.indexOf('debug') !== -1) {
        window.console.warn(arguments);
    }
    return true;
}

/**
 * Augment the object, adding a few shared methods to it.
 * @param  {Object} object the object to be augmented
 * @return {Object} the augmented object.
 */
function augmentObject(object) {
    if (typeof object === 'undefined') {
        err('tried to augment', object);
        return null;
    }
    if (!object.augmented) {
        /**
         * extend an object with another object.
         *
         * @param  {Function} item       child function
         * @param  {Function|Object} Inheritant parent function/object
         *
         * @return {Object}            Returns the object with its augmentation
         */
        object.extend = object.extend || function extend(Child, Parent) {
            if (typeof Child === 'undefined' || typeof Parent === 'undefined') {
                err('Tried to extend', Child, 'with', Parent);
                return null;
            }
            if (typeof Parent === 'function') {
                Child.prototype = new Parent();
                Child.constructor = Child;
            } else {
                Child.prototype = Parent;
                Child.constructor = Child;
            }
        };
        object.augmented = true;
    }
    return object;
}
exports.augmentObject = augmentObject;
exports.err = err;
exports.log = log;
exports.warn = warn;

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
/*global $*/
/**
 * @author scottvanlooy
 */

var OBJMIXINS, that;

function getAttr(str, attr) {
    return (str.split(new RegExp('\\b' + attr + '='))[1] || '').split('&')[0];
}
function $UI(object) {
    var i;
    for (i in OBJMIXINS) {
        if (OBJMIXINS.hasOwnProperty(i)) {
            object[i] = OBJMIXINS[i];
        }
    }
}
function $Controller(Controller) {
    Controller.createXHR = Controller.createJSONP = function (jsonp) {
        if (jsonp) {
            return {
                open: function open(options) {
                    options.dataType = 'jsonp';
                    if (typeof jsonp === 'string') {
                        if (typeof window[jsonp] !== 'function') {
                            window[jsonp] = function (obj) {
                                options.success(obj);
                                delete window[jsonp];
                            };
                        }
                    }
                    $.ajax(options);
                }
            };
        }
        return {
            open: function open(options) {
                $.ajax(options);
            }
        };
    };
}
OBJMIXINS = {
    init: true,
    superOpen: function superOpen(callback) {
        that = that || this;
        that.domNode.show();
        return callback ? callback() : null;
    },
    superClose: function superClose(callback) {
        that = that || this;
        that.domNode.hide();
        return callback ? callback() : null;
    },
    on: function on() {
        that = that || this;
        that.domNode.show();
    },
    off: function off() {
        that = that || this;
        that.domNode.hide();
    }
};

exports.default = {
    UI: $UI,
    Selector: $,
    Controller: $Controller,
    jQuery: true,
    getAttr: getAttr
};

},{}]},{},[6]);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJvYmplY3Rqcy1qcXVlcnkubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogQGF1dGhvciBTY290dCB2YW4gTG9veVxuICovXG5cbi8qKlxuICogdGFrZXMgdHdvIGFycmF5cyBvZiBzdHJpbmdzIGFuZCBjb21iaW5lcyB0aGVtLCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAbWV0aG9kIGNvbWJpbmVcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIxIGZpcnN0IGFycmF5IHRvIGNvbWJpbmVcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIyIHNlY29uZCBhcnJheSB0byBjb21iaW5lXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICBkZWR1cGVkIHVuc29ydGVkIGFycmF5IG9mIHN0cmluZ3NcbiAqL1xuXG5mdW5jdGlvbiBjb21iaW5lKGFycjEsIGFycjIpIHtcbiAgICB2YXIgdGFyciA9IGFycjEuY29uY2F0KGFycjIpLFxuICAgICAgICBsID0gdGFyci5sZW5ndGgsXG4gICAgICAgIG8gPSB7fSxcbiAgICAgICAgcmV0ID0gW10sXG4gICAgICAgIG4sXG4gICAgICAgIG5hbWU7XG4gICAgZm9yIChuID0gMDsgbiA8IGw7IG4rKykge1xuICAgICAgICBvW3RhcnJbbl1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChuYW1lIGluIG8pIHtcbiAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vKipcbiAqIHJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgYW4gYXJyYXkuXG4gKiBAbWV0aG9kIGlzQXJyYXlcbiAqIEBwYXJhbSAge0FycmF5fSAgbyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KG8pIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvKTtcbn1cblxuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTtcbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2hhcmVkID0gcmVxdWlyZSgnLi9TaGFyZWQnKTtcblxuZnVuY3Rpb24gYmFzZUNvbnRyb2xsZXIobWl4aW4pIHtcbiAgICAvKiogUFJJVkFURSBNRVRIT0RTICoqL1xuICAgIHZhciBCYXNlQ29udHJvbGxlciA9ICgwLCBfU2hhcmVkLmF1Z21lbnRPYmplY3QpKHt9KTtcblxuICAgIC8qKiBBUEkgTUVUSE9EUyAqKi9cbiAgICAvKipcbiAgICAgKiBPbiBlbnRlciBvZiB5b3VyIGNoaWxkIGNvbnRyb2xsZXIsIHlvdSBjYWxsIHRoZSB2aWV3IGFzc29jaWF0ZWQgd2l0aCB0aGF0IGNvbnRyb2xsZXJcbiAgICAgKiB1c2luZyB0aGUgY2FsbFZpZXcgbWV0aG9kLiBJdCBlaXRoZXIgaW5zdGFudGlhdGVzIHRoZSB2aWV3IG9yIGlmIGl0IGFscmVhZHkgZXhpc3RzXG4gICAgICogaXQgY2FsbHMgXCJlbnRlclwiIG9uIGl0LiBZb3VyIHZpZXcncyBpbml0IG11c3QgYWxzbyBjYWxsIGVudGVyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBuYW1lc3BhY2UgeW91ciBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZpZXcgICAgICB0aGUgbmFtZSBvZiB0aGUgdmlldyB5b3UncmUgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICByZXR1cm5zIHRoZSBpbnN0YW50aWF0ZWQgdmlldy5cbiAgICAgKi9cbiAgICBCYXNlQ29udHJvbGxlci5jYWxsVmlldyA9IGZ1bmN0aW9uIGNhbGxWaWV3KG5hbWVzcGFjZSwgdmlldykge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBCYXNlQ29udHJvbGxlci5lcnIoJ3RyaWVkIHRvIGNhbGwnLCB2aWV3LCAnb24gJywgbmFtZXNwYWNlLCAnbmFtZXNwYWNlJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWVzcGFjZVt2aWV3XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmFtZXNwYWNlW3ZpZXddID0gbmV3IG5hbWVzcGFjZVt2aWV3XSgpO1xuICAgICAgICAgICAgbmFtZXNwYWNlW3ZpZXddLmNvbnRyb2xsZXIgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gbmFtZXNwYWNlW3ZpZXddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZXNwYWNlW3ZpZXddLmVudGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZVt2aWV3XTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlbW92ZXMgdG9rZW5zIGluIGEgc3RyaW5nIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggdmFsdWVzLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nICB0aGUgc3RyaW5nIHRvIHJlcGxhY2UgdG9rZW5zIGluOlxuICAgICAqIGluIHRoZSBmb3JtYXQgb2YgXCJ0aGlzIGlzIG15L3t0b2tlbjF9LXt0b2tlbjJ9L3N0cmluZy97dG9rZW4tM31cIlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gdG9rZW5zIGFuIG9iamVjdCBvZiB0b2tlbnMgdG8gcmVwbGFjZTpcbiAgICAgKiB7XG4gICAgICogICB0b2tlbjE6ICdiZXJ0JyxcbiAgICAgKiAgIHRva2VuMjogJ2ZyZWQnLFxuICAgICAqICAgdG9rZW4zOiAxMlxuICAgICAqIH1cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgdG9rZW5pc2VkIHN0cmluZy5cbiAgICAgKi9cbiAgICBCYXNlQ29udHJvbGxlci50b2tlbmlzZXIgPSBmdW5jdGlvbiB0b2tlbmlzZXIoc3RyaW5nLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0b2tlbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBCYXNlQ29udHJvbGxlci5lcnIoJ3RyaWVkIHRvIHRva2VuaXNlJywgc3RyaW5nLCAnd2l0aCAnLCB0b2tlbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICBmb3IgKHRva2VuIGluIHRva2Vucykge1xuICAgICAgICAgICAgaWYgKHRva2Vucy5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3BsaXQoJ3snICsgdG9rZW4gKyAnfScpLmpvaW4odG9rZW5zW3Rva2VuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldERhdGEgLSBnZXRzIERBVEEgZnJvbSBhbiBleHRlcm5hbCByZXNvdXJjZSB1c2luZyBKU09OL0pTT05QLiBXaWxsIFBPU1RcbiAgICAgKiBmb3IgSlNPTiByZXF1ZXN0cywgY2FuIG9ubHkgR0VUIGZvciBKU09OUC4gVGVjaG5pY2FsbHksIEpTT05QIGlzIGluc2VjdXJlLFxuICAgICAqIGJlIHZlcnkgY2FyZWZ1bCB3aGVuIHVzaW5nIGl0LCBtYWtlIHN1cmUgdGhlIDNyZCBwYXJ0eSBpcyB0cnVzdHdvcnRoeS5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uIHlvdSByZXF1aXJlLlxuICAgICAqXG4gICAgICogPHByZT5cbiAgICAgKiB7XG4gICAgICogICB1cmw6e3N0cmluZ30gICAgICAgICAgdGhlIFVSTCB3ZSBnZXQgdGhlIGRhdGEgZnJvbS4gSWYgSlNPTlAsIHNob3VsZCBlaXRoZXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlID9jYWxsYmFjaz0gcGFyYW1ldGVyIGZvciBzZXJ2aWNlcyB0aGF0IGRvbid0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3cgZHluYW1pYyBjYWxsYmFjayBhc3NpZ25tZW50cywgb3IgYmUgY2FsbGJhY2tcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXIgZnJlZSB0byBhbGxvdyB0aGlzIGNvZGUgdG8gYXNzaWduIG9uZS5cbiAgICAgKlxuICAgICAqICAgZGF0YTp7c3RyaW5nfSwgICAgICAgIG5hbWUgdmFsdWUgcGFpcnNcbiAgICAgKlxuICAgICAqICAgc3VjY2Vzczp7ZnVuY3Rpb24oKX0sIGNhbGxiYWNrIGZ1bmN0aW9uIG9uIHN1Y2Nlc3MuIFRoaXMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogICBlcnJvcjp7ZnVuY3Rpb24oKX0sICAgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG8gc29tZXRoaW5nIG9uIGVycm9yLiBUaGlzIHdpbGxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBiZSBwYXNzZWQgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZXJyb3IuXG4gICAgICpcbiAgICAgKiAgIGpzb25wOntzdHJpbmd9ICAgICAgICB3aGVuIHNldCwgZm9yY2VzIEpTT05QIHdpdGggdGhlIHNwZWNpZmllZCBzdHJpbmcgYXMgY2FsbGJhY2sgbmFtZVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIDwvcHJlPlxuICAgICAqL1xuICAgIEJhc2VDb250cm9sbGVyLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHhocjtcbiAgICAgICAgaWYgKG9wdGlvbnMudXJsICYmIHR5cGVvZiBvcHRpb25zLnVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghQmFzZUNvbnRyb2xsZXIuY3JlYXRlWEhSIHx8ICFCYXNlQ29udHJvbGxlci5jcmVhdGVKU09OUCkge1xuICAgICAgICAgICAgICAgIG1peGluLkNvbnRyb2xsZXIoQmFzZUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgb24gdGhlIHNhbWUgZG9tYWluLCB3ZSBuZWVkIHRvIGRvIGFuIFhIUiByZXF1ZXN0LCBpZiBub3Qgd2UgZG8gYSBKU09OUC5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVybC5pbmRleE9mKCc6Ly8nKSA9PT0gLTEgfHwgb3B0aW9ucy51cmwubWF0Y2god2luZG93LmxvY2F0aW9uLnByb3RvY29sKSAmJiBvcHRpb25zLnVybC5pbmRleE9mKHdpbmRvdy5sb2NhdGlvbi5ob3N0KSAhPT0gLTEgJiYgIW9wdGlvbnMuanNvbnApIHtcbiAgICAgICAgICAgICAgICB4aHIgPSBCYXNlQ29udHJvbGxlci5jcmVhdGVYSFIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeGhyID0gQmFzZUNvbnRyb2xsZXIuY3JlYXRlSlNPTlAob3B0aW9ucy5qc29ucCB8fCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhoci5vcGVuKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCYXNlQ29udHJvbGxlci5jcmVhdGVDb250cm9sbGVyID0gQmFzZUNvbnRyb2xsZXIuZXh0ZW5kLmN1cnJ5KHVuZGVmaW5lZCwgQmFzZUNvbnRyb2xsZXIpO1xuICAgIHJldHVybiBCYXNlQ29udHJvbGxlcjtcbn1cbi8qKlxuICogQGF1dGhvciBTY290dCB2YW4gTG9veVxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGJhc2VDb250cm9sbGVyO1xuXG59LHtcIi4vU2hhcmVkXCI6N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2hhcmVkID0gcmVxdWlyZSgnLi9TaGFyZWQnKTtcblxuZnVuY3Rpb24gYmFzZVVJKG1peGluKSB7XG5cbiAgICB2YXIgQmFzZVVJID0gKDAsIF9TaGFyZWQuYXVnbWVudE9iamVjdCkoe30pO1xuXG4gICAgZnVuY3Rpb24gZihmbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKiBBUEkgTUVUSE9EUyAqKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByb290IGRvbSBub2RlIHRoYXQgdGhlIGxpYnJhcnkgdXNlcyB0byBmaW5kIG90aGVyIGRvbSBub2RlcyB3aGVuIGdlbmVyYXRpbmcgVUkgY29tcG9uZW50cy4gRGVmYXVsdHMgdG8gYm9keS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRvbU5vZGUgdGhlIHNlbGVjdG9yIGZvciB0aGUgZG9tTm9kZVxuICAgICAqL1xuICAgIEJhc2VVSS5zZXRSb290RG9tTm9kZSA9IGZ1bmN0aW9uIHNldFJvb3REb21Ob2RlKGRvbU5vZGUpIHtcbiAgICAgICAgQmFzZVVJLnJvb3QgPSBtaXhpbi5TZWxlY3Rvcihkb21Ob2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYSBVSSwgY2FjaGVzIGl0cyBkb21ub2RlIGFuZCBwcmVwYXJlcyBpdCBmb3IgdXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gaWQgLSB0aGUgZG9tIElELCBjbGFzc05hbWUgb3IgalF1ZXJ5IG9iamVjdCBvZiB0aGUgcm9vdCBlbGVtZW50IGZvciB0aGUgVUkuXG4gICAgICovXG4gICAgQmFzZVVJLnNldHVwVUkgPSBmdW5jdGlvbiBzZXR1cFVJKGlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgICAgICAgICBzZWxmLmRvbU5vZGUgPSBCYXNlVUkucm9vdCA/IEJhc2VVSS5yb290LmZpbmQoaWQpIDogbWl4aW4uU2VsZWN0b3IoaWQpO1xuICAgICAgICAgICAgc2VsZi5jb250ZW50Tm9kZSA9IHNlbGYuZG9tTm9kZS5maW5kKCcuY29udGVudCcpO1xuICAgICAgICAgICAgc2VsZi50aXRsZU5vZGUgPSBzZWxmLmRvbU5vZGUuZmluZCgnLnRpdGxlJyk7XG4gICAgICAgICAgICBzZWxmLnRlbXBsYXRlTm9kZSA9IHNlbGYuZG9tTm9kZS5maW5kKCcudGVtcGxhdGUnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHNlbGYuZm9vdGVyTm9kZSA9IHNlbGYuZG9tTm9kZS5maW5kKCcuZm9vdGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmLmluaXQpIHtcbiAgICAgICAgICAgIG1peGluLlVJKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHNldHVwKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhY3RpdmUgdmlldyBvbiBhIFVJIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3IGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IHdlIHdpc2ggdG8gc2V0IG9uIHRoZSBVSSBvYmplY3QuXG4gICAgICovXG4gICAgQmFzZVVJLnNldFZpZXcgPSBmdW5jdGlvbiBzZXRWaWV3KHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBzZXQgdmlldyBvbiBhIFVJIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnRseSBzZXQgdmlld1xuICAgICAqL1xuICAgIEJhc2VVSS5nZXRWaWV3ID0gZnVuY3Rpb24gZ2V0VmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogT3BlbnMgYSBVSSBvYmplY3QuIEFkZHMgYSBjbGFzcyBvZiBcIm9wZW5cIiB0byB0aGUgVUkncyBkb21Ob2RlLiBFaXRoZXIgYW5pbWF0ZSB1c2luZyBDU1MzXG4gICAgICogb3Igb3ZlcnJpZGUgdGhpcyB0byBjcmVhdGUgYSBKYXZhc2NyaXB0IGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBBIHJlZmVyZW5jZSB0byB0aGUgVUkgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgYSByZWZlcmVuY2UgdG8gdGhlIFVJIG9iamVjdCAoZm9yIGNoYWluaW5nKS5cbiAgICAgKi9cbiAgICBCYXNlVUkub3BlbiA9IGZ1bmN0aW9uIG9wZW4ob2JqKSB7XG4gICAgICAgIG9iaiA9IG9iaiB8fCB0aGlzO1xuICAgICAgICBvYmouZG9tTm9kZS5hZGRDbGFzcygnb3BlbicpO1xuICAgICAgICBvYmouaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyBhIFVJIG9iamVjdC4gUmVtb3ZlcyB0aGUgY2xhc3MgXCJvcGVuXCIgZnJvbSB0aGUgVUkncyBkb21Ob2RlLiBFaXRoZXIgYW5pbWF0ZSB1c2luZyBDU1MzIG9yIG92ZXJyaWRlXG4gICAgICogdGhpcyB0byBjcmVhdGUgYSBKYXZhc2NyaXB0IGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB0byBydW4gd2hlbiB0aGUgY2xvc2UgaXMgY29tcGxldGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgYSByZWZlcmVuY2UgdG8gdGhlIFVJIG9iamVjdCAoZm9yIGNoYWluaW5nKS5cbiAgICAgKi9cbiAgICBCYXNlVUkuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZShjYikge1xuICAgICAgICB0aGlzLmRvbU5vZGUucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGNiICYmIGYoY2IpKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudE5vZGUgZm9yIGEgVUkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIC5jb250ZW50IG5vZGUgb3IgdGhlIGRvbU5vZGUgb2YgdGhlIFVJIGluIHF1ZXN0aW9uLlxuICAgICAqL1xuICAgIEJhc2VVSS5nZXRDb250ZW50Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudE5vZGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgbWV0aG9kcyB0byB0aGUgVUkgb2JqZWN0IHlvdSdyZSBjcmVhdGluZy4gQXV0b21hdGljYWxseSBjcmVhdGUgc3VwZXIgbWV0aG9kcyB3aGVuIHRoZSBvYmplY3QgeW91J3JlXG4gICAgICogcGFzc2luZyBpbiBjb250YWlucyB0aGVzYW1lIG1ldGhvZHMgYXMgaXRzIHBhcmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3QgY29udGFpbmluZyB0aGUgbWV0aG9kcyB5b3Ugd2lzaCB0byBhZGQgdG8gdGhlIGhvc3Qgb2JqZWN0LlxuICAgICAqL1xuICAgIEJhc2VVSS5hZGRNZXRob2RzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1ldGhvZCwgYXJncztcbiAgICAgICAgZm9yIChtZXRob2QgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobWV0aG9kKSAmJiB0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdID0gb3B0aW9uc1ttZXRob2RdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3N1cGVyJyArIG1ldGhvZF0gPSB0aGlzW21ldGhvZF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbWV0aG9kXShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3N1cGVyJyArIG1ldGhvZF0oYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBvYmplY3QgYW5kIGV4dGVuZHMgaXQgd2l0aCB0aGUgQmFzZVVJXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBleHRlbmQ7XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBleHRlbmRlZCBvYmplY3RcbiAgICAgKi9cbiAgICBCYXNlVUkuY3JlYXRlVUkgPSBCYXNlVUkuZXh0ZW5kLmN1cnJ5KHVuZGVmaW5lZCwgQmFzZVVJKTtcbiAgICByZXR1cm4gQmFzZVVJO1xufSAvKipcbiAgICogQGF1dGhvciBTY290dCB2YW4gTG9veVxuICAgKi9cblxuZXhwb3J0cy5kZWZhdWx0ID0gYmFzZVVJO1xuXG59LHtcIi4vU2hhcmVkXCI6N31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfU2hhcmVkID0gcmVxdWlyZSgnLi9TaGFyZWQnKTtcblxudmFyIF9BcnJheVV0aWxzID0gcmVxdWlyZSgnLi9BcnJheVV0aWxzJyk7XG5cbi8qKlxuICogQGF1dGhvciBTY290dCB2YW4gTG9veVxuICovXG5cbi8qKiBQUklWQVRFIE1FVEhPRFMgKiovXG5mdW5jdGlvbiBiYXNlVmlldyhtaXhpbikge1xuICAgIHZhciBCYXNlVmlldyA9ICgwLCBfU2hhcmVkLmF1Z21lbnRPYmplY3QpKHt9KSxcbiAgICAgICAgZGVmYXVsdHMgPSBbXSxcbiAgICAgICAgbG9hZENvbXBvbmVudHMgPSBmdW5jdGlvbiBsb2FkQ29tcG9uZW50cyhuYW1lc3BhY2UsIHVpc0FycmF5LCB2aWV3LCBhZGRUb0RlZmF1bHRzKSB7XG4gICAgICAgIHZhciBhcnIgPSAoMCwgX0FycmF5VXRpbHMuY29tYmluZSkoZGVmYXVsdHMsIHVpc0FycmF5KSxcbiAgICAgICAgICAgIGwgPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgcmV0ID0ge307XG4gICAgICAgIHZpZXcgPSB2aWV3IHx8IHt9O1xuICAgICAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2xdICYmIG5hbWVzcGFjZVthcnJbbF1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lc3BhY2VbYXJyW2xdXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VbYXJyW2xdXSA9IG5ldyBuYW1lc3BhY2VbYXJyW2xdXSh2aWV3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VbYXJyW2xdXS5zZXRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkVG9EZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cy5wdXNoKGFycltsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldFthcnJbbF1dID0gbmFtZXNwYWNlW2FycltsXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIC8qKiBBUEkgTUVUSE9EUyAqKi9cbiAgICAvKipcbiAgICAgKiBTZXRzIGRlZmF1bHQgVUlzLiBUaGVzZSBVSXMgYXBwZWFyIG9uIGV2ZXJ5IHBhZ2UuIFNob3VsZCBvbmx5IGJlXG4gICAgICogY2FsbGVkIG9uY2UgaW4geW91ciBwcm9qZWN0IGFzIGl0IHJlcGxhY2VzIGV2ZXJ5dGhpbmcgZWFjaCB0aW1lLlxuICAgICAqIGdlbmVyYWxseSB5b3Ugd291bGQgY2FsbCB0aGlzIGZyb20geW91ciBhcHAgdmlldy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbnMgLSB0aGUgbmFtZXNwYWNlIHlvdXIgVUlzIGNhbiBiZSBmb3VuZCB1bmRlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXJyIC0gQW4gYXJyYXkgb2YgVUkgbmFtZXMuXG4gICAgICovXG4gICAgQmFzZVZpZXcuc2V0RGVmYXVsdENvbXBvbmVudHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0Q29tcG9uZW50cyhuYW1lc3BhY2UsIGFycikge1xuICAgICAgICBkZWZhdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4gbG9hZENvbXBvbmVudHMobmFtZXNwYWNlLCBhcnIsIG51bGwsIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgYXJyYXkgb2YgZGVmYXVsdCBjb21wb25lbnRzLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgQmFzZVZpZXcuZ2V0RGVmYXVsdENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q29tcG9uZW50cygpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxsIHZpZXdzIHJlcXVpcmUgYSBzZXQgb2YgY29tcG9uZW50cyB0aGF0IGV4aXN0IHdpdGhpbiB0aGF0IHZpZXcuIEV2ZXJ5XG4gICAgICogdmlldyBzaG91bGQgaGF2ZSBhbiBlbnRlciBtZXRob2QgdGhhdCBjYWxscyByZXF1aXJlcyBhbmQgYWRkcyB0aGUgZm9sbG93aW5nLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbmFtZXNwYWNlIHlvdXIgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtICB7U3RyaW5nW119IGFyciAgICAgICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgVUkgY29tcG9uZW50IG5hbWVzXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgICAgICBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0gICAgICAgICAgIGFycmF5IG9mIG9iamVjdHNcbiAgICAgKi9cbiAgICBCYXNlVmlldy5yZXF1aXJlcyA9IGZ1bmN0aW9uIHJlcXVpcmVzKG5hbWVzcGFjZSwgYXJyLCB2aWV3KSB7XG4gICAgICAgIHZhciB1aU1hcCA9ICgwLCBfQXJyYXlVdGlscy5jb21iaW5lKShhcnIsIGRlZmF1bHRzKTtcbiAgICAgICAgdmlldy51aXMgPSBsb2FkQ29tcG9uZW50cyhuYW1lc3BhY2UsIHVpTWFwLCB2aWV3KTtcbiAgICAgICAgcmV0dXJuIHZpZXcudWlzO1xuICAgIH07XG4gICAgQmFzZVZpZXcucm91dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvL3dyaXRlIGNvZGVcbiAgICB9O1xuICAgIEJhc2VWaWV3LmNhcHR1cmVSb3V0ZXMgPSBmdW5jdGlvbiByb3V0ZXMoKSB7XG4gICAgICAgIC8vd3JpdGUgY29kZVxuICAgIH07XG4gICAgQmFzZVZpZXcuY2FwdHVyZUZvcm1zID0gZnVuY3Rpb24gY2FwdHVyZUZvcm1zKCkge1xuICAgICAgICAvL3dyaXRlIGNvZGVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRha2VzIGFuIG9iamVjdCBhbmQgZXh0ZW5kcyBpdCB3aXRoIHRoZSBCYXNlVmlld1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gZXh0ZW5kO1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gZXh0ZW5kZWQgb2JqZWN0XG4gICAgICovXG4gICAgQmFzZVZpZXcuY3JlYXRlVmlldyA9IEJhc2VWaWV3LmV4dGVuZC5jdXJyeSh1bmRlZmluZWQsIEJhc2VWaWV3KTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHdoZXJlIHlvdSBjYW4gZmluZCBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHlvdXIgVUlzIG9uY2UgeW91J3ZlIGNhbGxlZCByZXF1aXJlc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgQmFzZVZpZXcudWlzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyIHRoYXQgaW5zdGFudGlhdGVkIHRoZSB2aWV3XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBCYXNlVmlldy5jb250cm9sbGVyID0gbnVsbDtcblxuICAgIHJldHVybiBCYXNlVmlldztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGJhc2VWaWV3O1xuXG59LHtcIi4vQXJyYXlVdGlsc1wiOjEsXCIuL1NoYXJlZFwiOjd9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NoYXJlZCA9IHJlcXVpcmUoJy4vU2hhcmVkJyk7XG5cbnZhciBfQmFzZVVJID0gcmVxdWlyZSgnLi9CYXNlVUknKTtcblxudmFyIF9CYXNlVUkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVVJKTtcblxudmFyIF9CYXNlQ29udHJvbGxlciA9IHJlcXVpcmUoJy4vQmFzZUNvbnRyb2xsZXInKTtcblxudmFyIF9CYXNlQ29udHJvbGxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9CYXNlQ29udHJvbGxlcik7XG5cbnZhciBfQmFzZVZpZXcgPSByZXF1aXJlKCcuL0Jhc2VWaWV3Jyk7XG5cbnZhciBfQmFzZVZpZXcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQmFzZVZpZXcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEBhdXRob3IgU2NvdHQgdmFuIExvb3lcbiAqIEBuYW1lIHsgT2JqZWN0SlM6W25hbWVdfVxuICovXG5mdW5jdGlvbiBvanMob3B0aW9ucykge1xuICAgIHZhciBjdXJyZW50VmlldyA9IHZvaWQgMCxcbiAgICAgICAgdmlld3MgPSB2b2lkIDAsXG4gICAgICAgIE1peGluID0gb3B0aW9ucy5NaXhpbixcbiAgICAgICAgU2VsZWN0b3IgPSBNaXhpbi5TZWxlY3RvcjtcblxuICAgIGZ1bmN0aW9uIE9iamVjdEpTKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdG9yKG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIFVSTCBmb3IgbGlicmFyeSBzY3JpcHRzIC0gZGV0ZXJtaW5lZCBieSB0aGUgbG9jYXRpb24gb2ZcbiAgICAgKiBvYmplY3QubWluPy5qc1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICAgIHZhciBCQVNFX1VSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgICAgIHZhciBtID0gc1tzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbS5zcmMucmVwbGFjZSgvW15cXC9dKz8kLywgJycpO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBzY3JpcHQgYXN5bmNocm9ub3VzbHkuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHNyYyAgaHJlZiBvZiB0aGUgc2NyaXB0IHRvIGxvYWQuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiICAgY2FsbGJhY2sgdG8gZmlyZSB1cG9uIGxvYWRpbmcuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGxvYWQgU2NyaXB0cyByZW1haW5pbmcgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgbGVuICBUb3RhbCBzY3JpcHRzIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgbnVtICBTY3JpcHQgaW5kZXhcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICBlcnIgIFNvbWV0aGluZyB0byBkbyBvbiBlcnJvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkU2NyaXB0KHNyYywgY2IsIGxvYWQsIGxlbiwgbnVtLCBlcnIpIHtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkZWQoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSB8fCAvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGxvYWQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWQgJiYgbGVuID09PSBudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2IuY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IuY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgICAgICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nICYmICFlcnIuY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgZXJyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgcy50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHMuc3JjID0gc3JjO1xuICAgICAgICBzLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHMub25sb2FkID0gcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBsb2FkZWQ7XG4gICAgICAgIHMub25lcnJvciA9IGVycm9yO1xuICAgICAgICBPYmplY3RKUygnaGVhZCcpLmFwcGVuZChzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhIG5hbWVzcGFjZS4gSWYgdGhlIG5hbWVzcGFjZSBkb2VzIG5vdCBleGlzdCwgaXQgd2lsbFxuICAgICAqIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxIC0gcmVxdWVzdCBpbiB0aGUgZm9ybWF0IG9mICdteS5uYW1lLnNwYWNlJ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0IC0gdGVzdCBmb3IgYSBtYW1lc3BhY2UuXG4gICAgICogQHJldHVybiB7T2JqZWN0fGZhbHNlfSBUaGUgbmFtZXNwYWNlIG9yIGZhbHNlIGlmIHRlc3QgaXMgdHJ1ZSBhbmQgdGhlIG5hbWVzcGFjZSBkb2Vzbid0IGV4aXN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVxTmFtZVNwYWNlKHJlcSwgdGVzdCkge1xuICAgICAgICB2YXIgdCwgeCwgdG5zLCBsO1xuICAgICAgICBpZiAoIXJlcSB8fCB0eXBlb2YgcmVxICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgKDAsIF9TaGFyZWQuZXJyKSgnZ2V0TmFtZVNwYWNlIGVycm9yIC0gcmVxdWlyZXMgYSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBcIm15Lm5hbWUuc3BhY2VcIicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXEubWF0Y2goJ1xcXFwuJykpIHtcbiAgICAgICAgICAgIHQgPSBbcmVxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQgPSByZXEuc3BsaXQoJy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0bnMgPSB3aW5kb3c7XG4gICAgICAgIGwgPSB0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IGw7IHgrKykge1xuICAgICAgICAgICAgaWYgKHRuc1t0W3hdXSkge1xuICAgICAgICAgICAgICAgIHRucyA9IHRuc1t0W3hdXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0bnMgPSB0bnNbdFt4XV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXF1aXJlcyBtZXRob2QuIFVzaW5nIHRoZSBsb2NhdGlvbiBvZiBvYmplY3QubWluPy5qcyBhcyB0aGUgYmFzZSwgY2FuXG4gICAgICogbG9hZCBvdGhlciBtb2R1bGVzLiBDaGVja3MgdG8gc2VlIGlmIHRoZXkgZXhpc3QgYW5kIGlmIHRoZXkgZG9uJ3QsIHdlIGdyYWJcbiAgICAgKiB0aGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcXVpcmVzIC0gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgYSBjb21wb25lbnQncyBwYXRoLlxuICAgICAqICdteWFwcC9tYWluL0hlbGxvLmpzJyB3b3VsZCBiZSB3cml0dGVuIGFzICdteWFwcC5tYWluLkhlbGxvJyBhbmQgSGVsbG8uanNcbiAgICAgKiB3b3VsZCBjb250YWlucyBhbiBvYmplY3QgYXQgdGhlIHNhbWUgbmFtZXNwYWNlXG4gICAgICogKG15YXBwLm1haW4uSGVsbG8gPSAoZnVuY3Rpb24oKXt9KCkpKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10uIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biB3aGVuIGxvYWRpbmcgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVxdWlyZXMocmVxdWlyZXMsIGNhbGxiYWNrLCBvaikge1xuICAgICAgICB2YXIgbCA9IHJlcXVpcmVzLmxlbmd0aCxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIGxvYWQgPSAwLFxuICAgICAgICAgICAgbixcbiAgICAgICAgICAgIGRvY2FsbGJhY2sgPSBmYWxzZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVRlc3Q7XG4gICAgICAgIG9qID0gb2ogfHwgJ25zJztcbiAgICAgICAgbmFtZXNwYWNlVGVzdCA9IGZ1bmN0aW9uIG5hbWVzcGFjZVRlc3QobmFtZXNwYWNlLCB0ZXN0KSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHN0ckFyciA9IHRlc3Quc3BsaXQoJy4nKSxcbiAgICAgICAgICAgICAgICBsID0gc3RyQXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgLy8gRmluZCBzdGFydGluZyBwb2ludC4gRWl0aGVyIG91ciBvd24gbmFtZXNwYWNlIG9yIHRoZSB3aW5kb3cuIElmIG5laXRoZXIsIHJldHVybiBmYWxzZS5cbiAgICAgICAgICAgIGlmICghcmV0W3N0ckFyclswXV0gJiYgIXdpbmRvd1tzdHJBcnJbMF1dKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHN0YXJ0aW5nIHBvaW50IGlzIHRoZSB3aW5kb3csIHNldCB3aW5kb3cgdG8gdGhlIHJldHVybiB2YWx1ZS5cbiAgICAgICAgICAgIGlmICghcmV0W3N0ckFyclswXV0gJiYgd2luZG93W3N0ckFyclswXV0pIHtcbiAgICAgICAgICAgICAgICByZXQgPSB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHAgPSAwOyBwIDwgbDsgcCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHJldFtzdHJBcnJbcF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXF1aXJlcyA9IFtyZXF1aXJlc107XG4gICAgICAgICAgICBsID0gcmVxdWlyZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsOyBuKyspIHtcbiAgICAgICAgICAgIGRvY2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHNyYyA9IG51bGw7XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlVGVzdChvaiwgcmVxdWlyZXNbbl0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBCQVNFX1VSTCArIHJlcXVpcmVzW25dLnJlcGxhY2UoL1xcLi9naSwgJy8nKSArICcuanMnO1xuICAgICAgICAgICAgICAgIGlmIChvai5maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkU2NyaXB0KHNyYywgY2FsbGJhY2ssIGxvYWQsIHJlcXVpcmVzLmxlbmd0aCwgbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LndyaXRlKCc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCInICsgc3JjICsgJ1wiPjxcXC9zY3JpcHQ+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhpcyBpdGVtLiBSdW4gY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgZG9jYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBvYmogdGhlIG5hbWUgb2YgdGhlIG9iamVjdCB0byBpbml0aWFsaXNlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgIG5zICB0aGUgbmFtZXNwYWNlIGl0IGxpdmVzIGluXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbZm5dICBBIGZ1bmN0aW9uIHRvIHJ1biBvbiB0aGUgbmV3bHkgaW5pdGlhbGlzZWQgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIG5ldyBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0T2JqKG9iaiwgbnMsIGZuKSB7XG4gICAgICAgIGlmICghbnMgfHwgIW5zW29ial0pIHtcbiAgICAgICAgICAgICgwLCBfU2hhcmVkLmVycikoJ0F0dGVtcHRlZCB0byBpbml0IG9iamVjdCcsIG9iaiwgJ2luIG5hbWVzcGFjZScsIG5zLCAnZmFpbGVkLicpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuc1tvYmpdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuc1tvYmpdID0gbmV3IG5zW29ial0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnNbb2JqXVtmbl0pIHtcbiAgICAgICAgICAgIG5zW29ial1bZm5dKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zW29ial07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgYWN0aXZlIHZpZXcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBhY3RpdmUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZpZXc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgdmlldy4gVXNlZCBhdCB0aGUgYm90dG9tIG9mIGFuIEhUTUwgcGFnZSB0byBjYWxsIHRoZSBhc3NvY2lhdGVkIEpTIHZpZXcgd2l0aCB0aGF0IHBhZ2UuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB2aWV3IFRoZSB2aWV3IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2aWV3KHZpZXcpIHtcbiAgICAgICAgaW5pdE9iaih2aWV3LCB2aWV3cywgJ2VudGVyJyk7XG4gICAgICAgIGN1cnJlbnRWaWV3ID0gdmlld3Nbdmlld107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5pdGlhbGlzZSB0aGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuY3VycnkgPSBGdW5jdGlvbi5wcm90b3R5cGUucGFydGlhbCB8fCBmdW5jdGlvbiBjdXJyeSgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBteUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgICAgICBpaSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBsbCA9IG15QXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsbDsgaWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkLnB1c2gobXlBcmdzW2lpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lZC5wdXNoKGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBjb21iaW5lZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGluaXQoKTtcblxuICAgIHZhciBiYXNlVUkgPSAoMCwgX0Jhc2VVSTIuZGVmYXVsdCkoTWl4aW4pO1xuICAgIHZhciBiYXNlQ29udHJvbGxlciA9ICgwLCBfQmFzZUNvbnRyb2xsZXIyLmRlZmF1bHQpKE1peGluKTtcbiAgICB2YXIgYmFzZVZpZXcgPSAoMCwgX0Jhc2VWaWV3Mi5kZWZhdWx0KShNaXhpbik7XG5cbiAgICBPYmplY3RKUy5OT09QID0gZnVuY3Rpb24gKCkge307XG4gICAgT2JqZWN0SlMucmVxTmFtZVNwYWNlID0gcmVxTmFtZVNwYWNlO1xuICAgIE9iamVjdEpTLnJlcXVpcmVzID0gcmVxdWlyZXM7XG4gICAgT2JqZWN0SlMuQkFTRV9VUkwgPSBCQVNFX1VSTDtcbiAgICBPYmplY3RKUy5hdWdtZW50T2JqZWN0ID0gX1NoYXJlZC5hdWdtZW50T2JqZWN0O1xuICAgIE9iamVjdEpTLmluaXRPYmogPSBpbml0T2JqO1xuICAgIE9iamVjdEpTLmdldFZpZXcgPSBnZXRWaWV3O1xuICAgIE9iamVjdEpTLnZpZXcgPSB2aWV3O1xuICAgIE9iamVjdEpTLmxvYWRTY3JpcHQgPSBsb2FkU2NyaXB0O1xuICAgIE9iamVjdEpTLmVyciA9IF9TaGFyZWQuZXJyO1xuICAgIE9iamVjdEpTLmxvZyA9IF9TaGFyZWQubG9nO1xuICAgIE9iamVjdEpTLndhcm4gPSBfU2hhcmVkLndhcm47XG4gICAgT2JqZWN0SlMuY3JlYXRlVUkgPSBiYXNlVUkuY3JlYXRlVUk7XG4gICAgT2JqZWN0SlMuc2V0Um9vdERvbU5vZGUgPSBiYXNlVUkuc2V0Um9vdERvbU5vZGU7XG4gICAgT2JqZWN0SlMuY3JlYXRlVmlldyA9IGJhc2VWaWV3LmNyZWF0ZVZpZXc7XG4gICAgT2JqZWN0SlMuY3JlYXRlQ29udHJvbGxlciA9IGJhc2VDb250cm9sbGVyLmNyZWF0ZUNvbnRyb2xsZXI7XG4gICAgcmV0dXJuIE9iamVjdEpTO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBvanM7XG5cbn0se1wiLi9CYXNlQ29udHJvbGxlclwiOjIsXCIuL0Jhc2VVSVwiOjMsXCIuL0Jhc2VWaWV3XCI6NCxcIi4vU2hhcmVkXCI6N31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfalF1ZXJ5ID0gcmVxdWlyZSgnLi9qUXVlcnknKTtcblxudmFyIF9qUXVlcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfalF1ZXJ5KTtcblxudmFyIF9Db3JlID0gcmVxdWlyZSgnLi9Db3JlJyk7XG5cbnZhciBfQ29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db3JlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gT2JqZWN0SlMoKSB7XG4gICAgdmFyIGNvcmUgPSBuZXcgX0NvcmUyLmRlZmF1bHQoe1xuICAgICAgICBNaXhpbjogX2pRdWVyeTIuZGVmYXVsdFxuICAgIH0pO1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgICAgd2luZG93Lk9iamVjdEpTID0gY29yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcmU7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBPYmplY3RKUygpO1xuXG59LHtcIi4vQ29yZVwiOjUsXCIuL2pRdWVyeVwiOjh9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBJZiB0aGUgc3RyaW5nIFwiZGVidWdcIiBhcHBlYXJzIGluIHRoZSBVUkwsIHdlIHdyaXRlIHRvIHRoZSBjb25zb2xlIGlmIHRoZXJlIGlzIG9uZVxuICogd2hhdGV2ZXIgd2UgZmVlZCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGVycigpIHtcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSAnZGVidWcnKSB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBJZiB0aGUgc3RyaW5nIFwiZGVidWdcIiBhcHBlYXJzIGluIHRoZSBVUkwsIHdlIHdyaXRlIHRvIHRoZSBjb25zb2xlIGlmIHRoZXJlIGlzIG9uZVxuICogd2hhdGV2ZXIgd2UgZmVlZCBpbnRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGxvZygpIHtcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJ2RlYnVnJykgIT09IC0xKSB7XG4gICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogSWYgdGhlIHN0cmluZyBcImRlYnVnXCIgYXBwZWFycyBpbiB0aGUgVVJMLCB3ZSB3cml0ZSB0byB0aGUgY29uc29sZSBpZiB0aGVyZSBpcyBvbmVcbiAqIHdoYXRldmVyIHdlIGZlZWQgaW50byB0aGlzIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGlmICh3aW5kb3cgJiYgd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignZGVidWcnKSAhPT0gLTEpIHtcbiAgICAgICAgd2luZG93LmNvbnNvbGUud2Fybihhcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IHRoZSBvYmplY3QsIGFkZGluZyBhIGZldyBzaGFyZWQgbWV0aG9kcyB0byBpdC5cbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgdG8gYmUgYXVnbWVudGVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBhdWdtZW50ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhdWdtZW50T2JqZWN0KG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlcnIoJ3RyaWVkIHRvIGF1Z21lbnQnLCBvYmplY3QpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFvYmplY3QuYXVnbWVudGVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgYW4gb2JqZWN0IHdpdGggYW5vdGhlciBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVtICAgICAgIGNoaWxkIGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufE9iamVjdH0gSW5oZXJpdGFudCBwYXJlbnQgZnVuY3Rpb24vb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICBSZXR1cm5zIHRoZSBvYmplY3Qgd2l0aCBpdHMgYXVnbWVudGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvYmplY3QuZXh0ZW5kID0gb2JqZWN0LmV4dGVuZCB8fCBmdW5jdGlvbiBleHRlbmQoQ2hpbGQsIFBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIFBhcmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlcnIoJ1RyaWVkIHRvIGV4dGVuZCcsIENoaWxkLCAnd2l0aCcsIFBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFBhcmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBDaGlsZC5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBQYXJlbnQ7XG4gICAgICAgICAgICAgICAgQ2hpbGQuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb2JqZWN0LmF1Z21lbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5leHBvcnRzLmF1Z21lbnRPYmplY3QgPSBhdWdtZW50T2JqZWN0O1xuZXhwb3J0cy5lcnIgPSBlcnI7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMud2FybiA9IHdhcm47XG5cbn0se31dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4vKmdsb2JhbCAkKi9cbi8qKlxuICogQGF1dGhvciBzY290dHZhbmxvb3lcbiAqL1xuXG52YXIgT0JKTUlYSU5TLCB0aGF0O1xuXG5mdW5jdGlvbiBnZXRBdHRyKHN0ciwgYXR0cikge1xuICAgIHJldHVybiAoc3RyLnNwbGl0KG5ldyBSZWdFeHAoJ1xcXFxiJyArIGF0dHIgKyAnPScpKVsxXSB8fCAnJykuc3BsaXQoJyYnKVswXTtcbn1cbmZ1bmN0aW9uICRVSShvYmplY3QpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgaW4gT0JKTUlYSU5TKSB7XG4gICAgICAgIGlmIChPQkpNSVhJTlMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtpXSA9IE9CSk1JWElOU1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uICRDb250cm9sbGVyKENvbnRyb2xsZXIpIHtcbiAgICBDb250cm9sbGVyLmNyZWF0ZVhIUiA9IENvbnRyb2xsZXIuY3JlYXRlSlNPTlAgPSBmdW5jdGlvbiAoanNvbnApIHtcbiAgICAgICAgaWYgKGpzb25wKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2pzb25wJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29ucCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93W2pzb25wXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1tqc29ucF0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2pzb25wXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICQuYWpheChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAkLmFqYXgob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbk9CSk1JWElOUyA9IHtcbiAgICBpbml0OiB0cnVlLFxuICAgIHN1cGVyT3BlbjogZnVuY3Rpb24gc3VwZXJPcGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoYXQgPSB0aGF0IHx8IHRoaXM7XG4gICAgICAgIHRoYXQuZG9tTm9kZS5zaG93KCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKCkgOiBudWxsO1xuICAgIH0sXG4gICAgc3VwZXJDbG9zZTogZnVuY3Rpb24gc3VwZXJDbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGF0ID0gdGhhdCB8fCB0aGlzO1xuICAgICAgICB0aGF0LmRvbU5vZGUuaGlkZSgpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjaygpIDogbnVsbDtcbiAgICB9LFxuICAgIG9uOiBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgdGhhdCA9IHRoYXQgfHwgdGhpcztcbiAgICAgICAgdGhhdC5kb21Ob2RlLnNob3coKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKCkge1xuICAgICAgICB0aGF0ID0gdGhhdCB8fCB0aGlzO1xuICAgICAgICB0aGF0LmRvbU5vZGUuaGlkZSgpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBVSTogJFVJLFxuICAgIFNlbGVjdG9yOiAkLFxuICAgIENvbnRyb2xsZXI6ICRDb250cm9sbGVyLFxuICAgIGpRdWVyeTogdHJ1ZSxcbiAgICBnZXRBdHRyOiBnZXRBdHRyXG59O1xuXG59LHt9XX0se30sWzZdKTtcbiJdLCJmaWxlIjoib2JqZWN0anMtanF1ZXJ5Lm1pbi5qcyJ9
